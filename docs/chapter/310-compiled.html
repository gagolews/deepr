<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="Deep R Programming" name="citation_title" />
<meta content="Marek Gagolewski" name="citation_author" />
<meta content="2024" name="citation_date" />
<meta content="2024" name="citation_publication_date" />
<meta content="https://deepr.gagolewski.com/deepr.pdf" name="citation_pdf_url" />
<meta content="https://deepr.gagolewski.com" name="citation_public_url" />
<meta content="10.5281/zenodo.7490464" name="citation_doi" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="citation_abstract" />
<meta content="summary" name="twitter:card" />
<meta content="Deep R Programming" name="twitter:title" />
<meta content="Deep R Programming" name="og:title" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="twitter:description" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="og:description" />
<meta content="gagolews/deepr" name="og:site_name" />
<meta content="https://deepr.gagolewski.com" name="og:url" />
<meta content="https://deepr.gagolewski.com/_images/cover.png" name="twitter:image" />
<meta content="https://deepr.gagolewski.com/_images/cover.png" name="og:image" />
<meta content="https://deepr.gagolewski.com" name="DC.identifier" />
<meta content="Marek Gagolewski" name="DC.publisher" />
<meta content="INDEX,FOLLOW" name="robots" />
<meta content="book" name="og:type" />
<meta content="9780645571929" name="og:book:isbn" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="15. Unevaluated expressions (*)" href="320-language.html" /><link rel="prev" title="13. Graphics" href="250-graphics.html" />
        <link rel="canonical" href="https://deepr.gagolewski.com/chapter/310-compiled.html" />

    <link rel="shortcut icon" href="https://www.gagolewski.com/_static/img/deepr.png"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>14. Interfacing compiled code (**) - Deep R Programming</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=1e0fcfc0" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Deep R Programming</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
<div class="sidebar-logo-container">
  <a class="sidebar-brand" href="../index.html"><img class="sidebar-logo" src="https://www.gagolewski.com/_static/img/deepr.png" alt="Logo"/></a>
</div>

<span class="sidebar-brand-text">
<a class="sidebar-brand" href="../index.html">Deep R Programming</a>
</span>
<div class="sidebar-brand">
An open-access textbook<br />
by <a href='https://www.gagolewski.com/' style="display: contents">Marek Gagolewski</a><br />
v1.0.1
</div>
<form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author</a></li>
<li class="toctree-l1"><a class="reference external" href="https://deepr.gagolewski.com/deepr.pdf">This book in PDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../order-paper-copy.html">Order a paper copy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/deepr">Report bugs or typos (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching-data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/">Data wrangling with Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Start here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deep</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-basics.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-numeric.html">2. Numeric vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-logical.html">3. Logical vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="140-list.html">4. Lists and attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="150-indexing.html">5. Vector indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="160-character.html">6. Character vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="170-function.html">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="180-flow.html">8. Flow of execution</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deeper</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="210-design.html">9. Designing functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="220-s3.html">10. S3 classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="230-matrix.html">11. Matrices and other arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="240-data-frame.html">12. Data frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="250-graphics.html">13. Graphics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deepest</span></p>
<ul class="current">
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">14. Interfacing compiled code (**)</a></li>
<li class="toctree-l1"><a class="reference internal" href="320-language.html">15. Unevaluated expressions (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="330-environment.html">16. Environments and evaluation (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="340-lazy.html">17. Lazy evaluation (**)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">References</a></li>
</ul>

</div></div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/gagolews/deepr" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="interfacing-compiled-code">
<span id="chap-compiled"></span><h1><span class="section-number">14. </span>Interfacing compiled code (**)<a class="headerlink" href="#interfacing-compiled-code" title="Link to this heading">¶</a></h1>
<blockquote>
<div><p><em>This open-access textbook
is, and will remain, freely available for everyone’s enjoyment
(also in <a class="reference external" href="https://deepr.gagolewski.com/deepr.pdf">PDF</a>;
a paper copy can also be <a class="reference internal" href="../order-paper-copy.html"><span class="doc std std-doc">ordered</span></a>).
It is a non-profit project. Although available online, it is a whole course,
and should be read from the beginning to the end.
Refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks. Any
<a class="reference external" href="https://github.com/gagolews/deepr">bug/typo reports/fixes</a>
are appreciated. Make sure to check out
<a class="reference external" href="https://datawranglingpy.gagolewski.com/"><em>Minimalist Data Wrangling with Python</em></a>
<span id="id1">[<a class="reference internal" href="999-bibliography.html#id3" title="Gagolewski, M. (2024).  Minimalist Data Wrangling with Python. URL: https://datawranglingpy.gagolewski.com/, DOI: 10.5281/zenodo.6451068.">27</a>]</span>, too.</em></p>
</div></blockquote>
<p>R is an effective <em>glue</em> language. It is suitable for composing
whole data wrangling pipelines: from data import through processing,
analysis, and visualisation to export. It makes using and connecting
larger <em>building blocks</em> very convenient.</p>
<p>R is also a competent tool for developing quick and dirty
prototypes of standalone, general-purpose algorithms,
especially if they are of <em>numerical</em> nature.
Nevertheless, for performance reasons, we may consider rewriting
computing-intensive tasks in C or C++<a class="footnote-reference brackets" href="#footlangs" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.
Such a move can be beneficial if we need a method that:</p>
<ul class="simple">
<li><p>has higher memory or time complexity
when programmed using vectorised R functions
than its straightforward implementation,</p></li>
<li><p>has an <em>iterative</em> or <em>recursive</em> nature, e.g., involving unvectorisable
<em>for</em> or <em>while</em> loops,</p></li>
<li><p>relies on complicated dynamic data structures
(e.g., hash maps, linked lists, or trees),</p></li>
<li><p>needs methods provided elsewhere and not available
in R (e.g., other C or C++ libraries).</p></li>
</ul>
<p>In the current chapter, we will demonstrate that R works very well as
a user-friendly interface to compiled code.</p>
<p>This topic is overall very technical. The definitive reference
is the <em>Writing R Extensions</em> manual <span id="id3">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>, but see also Chapter 11
of <span id="id4">[<a class="reference internal" href="999-bibliography.html#id19" title="Chambers, J.M. (2008).  Software for Data Analysis. Programming with R. Springer.">10</a>]</span>. Furthermore, R’s source code provides many working
examples of how to deal with R objects in C.</p>
<p>Here, we will only cover the most important rudiments.
We will focus on writing or interfacing <em>portable</em><a class="footnote-reference brackets" href="#rcpp" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
function libraries that only rely on <em>simple</em><a class="footnote-reference brackets" href="#noaltrep" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> data structures
(e.g., arrays of the type <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code>).
Thanks to this, we will be able to reuse
them in other environments such as Python (e.g., via Cython) or Julia.
Remember that R is one of <em>many</em> languages out there.</p>
<p>We assume some knowledge of the C language; see <span id="id7">[<a class="reference internal" href="999-bibliography.html#id36" title="Kernighan, B.W. and Ritchie, D. (1988).  The C Programming Language. Prentice Hall.">38</a>]</span>.
The reader can skip this chapter now and return to it later.
The remaining material is not contingent on the current one.</p>
<p>From now on, we take for granted that our environment
can successfully build a source package with C code, as mentioned in
<a class="reference internal" href="170-function.html#sec-src-package"><span class="std std-numref">Section 7.3.1.2</span></a>. In particular, W****ws and m**OS users should
install, respectively, <strong class="program">RTools</strong> and <strong class="program">Xcode</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid ambiguity, in the main text, calls to C functions will be
denoted by the “<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code>” prefix, e.g.,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">spanish_inquisition</strong><code class="code docutils literal notranslate"><span class="pre">()</span></code>.</p>
</div>
<section id="c-and-c-code-in-r">
<h2><span class="section-number">14.1. </span>C and C++ code in R<a class="headerlink" href="#c-and-c-code-in-r" title="Link to this heading">¶</a></h2>
<section id="source-files-for-compiled-code-in-r-packages">
<h3><span class="section-number">14.1.1. </span>Source files for compiled code in R packages<a class="headerlink" href="#source-files-for-compiled-code-in-r-packages" title="Link to this heading">¶</a></h3>
<p>Perhaps the most versatile way to interact with portable C code
is via standalone R packages. For the purpose of the current
chapter, we created a demo project
available at <a class="reference external" href="https://github.com/gagolews/cpackagedemo">https://github.com/gagolews/cpackagedemo</a>.</p>
<div class="proof proof-type-exercise" id="id31">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.1</span>
        
    </div><div class="proof-content">
<p>Inspect the structure of <strong class="program">cpackagedemo</strong>.
Note that C source files are located in the <code class="file docutils literal notranslate"><span class="pre">src/</span></code> subdirectory.
Build and install the package using <strong class="command">install.packages</strong>
or the “<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">INSTALL</span></code>” command. Then, load the package in R and call
<strong class="command">my_sum</strong> defined there on some numeric vector.</p>
</div></div><p>The package provides an R interface to one C function,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum</strong>, written in the
most portable fashion possible.
Its declaration is included in the <code class="file docutils literal notranslate"><span class="pre">src/cfuns.h</span></code> file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __CFUNS_H</span>
<span class="cp">#define __CFUNS_H</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">my_c_sum</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>The function accepts a pointer to the start of a numeric sequence
and its size, which is a standard<a class="footnote-reference brackets" href="#footstride" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> way of representing
an array of <code class="docutils literal notranslate"><span class="pre">double</span></code>s.</p>
<p>Its definition is given in <code class="file docutils literal notranslate"><span class="pre">src/cfuns.c</span></code>. We see that it is
nothing more than a simple sum of all the elements in an array:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cfuns.h&quot;</span>

<span class="cm">/* computes the sum of all elements in an array x of size n */</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">my_c_sum</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* this code does not treat potential missing values specially</span>
<span class="cm">           (they are kinds of NaNs); to fix this, add:</span>
<span class="cm">        if (ISNA(x[i])) return NA_REAL;  // #include &lt;R.h&gt;  */</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>To make <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum</strong> available in R,
we will have to introduce a wrapper around it that works
with the data structures from the first part of this jolly book.
We know that an R function accepts objects of <em>any</em> kind
on input and yields <em>anything</em> as a result.
In the next section, we will explain that we get access
to R objects via special pointers of the type <code class="docutils literal notranslate"><span class="pre">SEXP</span></code> (S expressions).</p>
<p>And so we declare our R-callable wrapper in <code class="file docutils literal notranslate"><span class="pre">src/rfuns.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __RFUNS_H</span>
<span class="cp">#define __RFUNS_H</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;R.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Rinternals.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Rmath.h&gt;</span>

<span class="n">SEXP</span><span class="w"> </span><span class="nf">my_c_sum_wrapper</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>The actual definition is included in <code class="file docutils literal notranslate"><span class="pre">src/rfuns.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;rfuns.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cfuns.h&quot;</span>

<span class="cm">/* a wrapper around my_c_sum callable from R */</span>
<span class="n">SEXP</span><span class="w"> </span><span class="nf">my_c_sum_wrapper</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* the caller is expected to prepare the arguments</span>
<span class="cm">           (doing it at the C level is tedious work) */</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be a vector of the type &#39;double&#39;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_c_sum</span><span class="p">(</span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarReal</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The arguments could be, technically speaking, prepared at the C level.
For instance, if <code class="docutils literal notranslate"><span class="pre">x</span></code> turned out to be an integer vector,
we could have converted it to the <code class="docutils literal notranslate"><span class="pre">double</span></code> one
(they are two different types; see <a class="reference internal" href="160-character.html#sec-integer"><span class="std std-numref">Section 6.4.1</span></a>).
Nevertheless, overall, it is very burdensome. It is easier to use pure R code
to ensure that the arguments are of the correct form as well as to beautify
the outputs.</p>
<p>This explains why we only assert the enjoyment of
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_isReal</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code>.
It guarantees that the <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">REAL</strong> and
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">XLENGTH</strong>
functions correctly return the pointer to the start of the sequence
and its length, respectively.</p>
<p>Once <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum</strong> is called,
we must convert it to an R object so that it can be returned to our
environment. Here, it is a newly allocated
numeric vector of length one. We did this by calling
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_ScalarReal</strong>.</p>
<div style="margin-top: 1em"></div><p>Although optional (see Section 5.4 of <span id="id9">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>),
we will register <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum_wrapper</strong>
as a callable function explicitly. This way, R will not be struggling
to find the specific entry point in the resulting dynamically linked library
(DLL). We do this in <code class="file docutils literal notranslate"><span class="pre">src/cpackagedemo.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;R_ext/Rdynload.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;rfuns.h&quot;</span>

<span class="cm">/* the list of functions available in R via a call to .Call():</span>
<span class="cm">   each entry is like {exported_name, fun_pointer, number_of_arguments} */</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">R_CallMethodDef</span><span class="w"> </span><span class="n">cCallMethods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;my_c_sum_wrapper&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">DL_FUNC</span><span class="p">)</span><span class="o">&amp;</span><span class="n">my_c_sum_wrapper</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">  </span><span class="c1">// the end of the list (sentinel)</span>
<span class="p">};</span>

<span class="cm">/* registers the list of callable functions */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">R_init_cpackagedemo</span><span class="p">(</span><span class="n">DllInfo</span><span class="w"> </span><span class="o">*</span><span class="n">dll</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">R_registerRoutines</span><span class="p">(</span><span class="n">dll</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">cCallMethods</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">R_useDynamicSymbols</span><span class="p">(</span><span class="n">dll</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>The function can be invoked from R using <strong class="command">.Call</strong>.
Here are the contents of <code class="file docutils literal notranslate"><span class="pre">R/my_sum.R</span></code>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">my_sum</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1"># prepare input data:</span>
<span class="w">    </span><span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="nf">is.double</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.double</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">.Call</span><span class="p">(</span><span class="s">&quot;my_c_sum_wrapper&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">PACKAGE</span><span class="o">=</span><span class="s">&quot;cpackagedemo&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># some rather random postprocessing:</span>
<span class="w">    </span><span class="nf">attr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;what&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">deparse</span><span class="p">(</span><span class="nf">substitute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="w">    </span><span class="n">s</span>
<span class="p">}</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>And, finally, here is the package <code class="file docutils literal notranslate"><span class="pre">NAMESPACE</span></code> file responsible
for registering the exported R names and indicating the DLL to use:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">export</span><span class="p">(</span><span class="n">my_sum</span><span class="p">)</span>
<span class="nf">useDynLib</span><span class="p">(</span><span class="n">cpackagedemo</span><span class="p">)</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p>Once the package is built and installed
(e.g., by running “<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">INSTALL</span> <span class="pre">&lt;pkgdir&gt;</span></code>” in the
terminal or calling <strong class="command">install.packages</strong>),
we can test it by calling:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">library</span><span class="p">(</span><span class="s">&quot;cpackagedemo&quot;</span><span class="p">)</span>
<span class="nf">my_sum</span><span class="p">(</span><span class="nf">runif</span><span class="p">(</span><span class="m">100</span><span class="p">)</span><span class="o">/</span><span class="m">100</span><span class="p">)</span>
<span class="c1">## [1] 0.49856</span>
<span class="c1">## attr(,&quot;what&quot;)</span>
<span class="c1">## [1] &quot;runif(100)/100&quot;</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id32">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.2</span>
        
    </div><div class="proof-content">
<p>Extend the package by adding a function to compute the index of the greatest
element in a numeric vector. Note that C uses 0-based array indexing whereas
in R, the first element is at index 1. Compare its run time against
<strong class="command">which.max</strong> using <strong class="command">proc.time</strong>.</p>
</div></div></section>
<section id="r-cmd-shlib">
<h3><span class="section-number">14.1.2. </span><code class="code docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">SHLIB</span></code><a class="headerlink" href="#r-cmd-shlib" title="Link to this heading">¶</a></h3>
<p>The “<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">SHLIB</span> <span class="pre">&lt;files&gt;</span></code>” shell command compiles one or more source files
without the need for turning them into standalone packages;
see <span id="id10">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>. Then, <strong class="command">dyn.load</strong> loads the resulting DLL.</p>
<div class="proof proof-type-exercise" id="id33">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.3</span>
        
    </div><div class="proof-content">
<p>(*) Compile <code class="file docutils literal notranslate"><span class="pre">src/cfuns.c</span></code> and <code class="file docutils literal notranslate"><span class="pre">src/rfuns.c</span></code> from our
demo package using “<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">SHLIB</span></code>”. Call <strong class="command">dyn.load</strong>.
Write an R function that uses <strong class="command">.Call</strong> to invoke
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum_wrapper</strong> from the second source file.</p>
</div></div><p>The direct <code class="docutils literal notranslate"><span class="pre">SHLIB</span></code> approach is convenient for learning C programming,
including running simple examples. We will thus use it
for didactic reasons in this chapter.
The <code class="file docutils literal notranslate"><span class="pre">inst/examples/csource.R</span></code> file in our demo package
includes the implementation of an R function called <strong class="command">csource</strong>.
It compiles a given C source file, and loads the resulting DLL.
It also extracts and executes a designated R code chunk
preferably defining a function that refers to <strong class="command">.Call</strong>.</p>
<p>Here is an example source file, <code class="file docutils literal notranslate"><span class="pre">inst/examples/helloworld.c</span></code>
in the <strong class="program">cpackagedemo</strong> source code repository:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// the necessary header files are automatically included by `csource`</span>

<span class="n">SEXP</span><span class="w"> </span><span class="nf">C_hello</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Rprintf</span><span class="p">(</span><span class="s">&quot;The mill&#39;s closed. There&#39;s no more work. We&#39;re destitute.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="w">        </span><span class="s">&quot;I&#39;m afraid I&#39;ve no choice but to sell you all &quot;</span>
<span class="w">        </span><span class="s">&quot;for scientific experiments.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm"># this chunk will be extracted and executed by `csource`.</span>

<span class="cm">hello &lt;- function()</span>
<span class="cm">    invisible(.Call(&quot;C_hello&quot;, PACKAGE=&quot;helloworld&quot;))</span>

<span class="cm">R */</span>
</pre></div>
</div>
<p>Let’s compile it and call the aforementioned R function.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">source</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/csource.R&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># defines csource</span>
<span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/helloworld.c&quot;</span><span class="p">)</span>
<span class="nf">hello</span><span class="p">()</span>
<span class="c1">## The mill&#39;s closed. There&#39;s no more work. We&#39;re destitute.</span>
<span class="c1">## I&#39;m afraid I&#39;ve no choice but to sell you all for scientific experiments.</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id34">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.4</span>
        
    </div><div class="proof-content">
<p>(*)
C++, which can be thought of as a superset of the C language
(but the devil is in the detail), is also supported.
Change the name of the aforementioned file to <code class="file docutils literal notranslate"><span class="pre">helloworld2.cpp</span></code>,
add <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> before the function declaration,
pass <code class="docutils literal notranslate"><span class="pre">PACKAGE=&quot;helloworld2&quot;</span></code> to <strong class="command">.Call</strong>,
and run <strong class="command">csource</strong> on the new file.</p>
</div></div><div class="proof proof-type-exercise" id="id35">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.5</span>
        
    </div><div class="proof-content">
<p>(*)
Verify that C and C++ source files can coexist in R packages.</p>
</div></div><div class="proof proof-type-example" id="id36">

    <div class="proof-title">
        <span class="proof-type">Example 14.6</span>
        
    </div><div class="proof-content">
<p>(*) It might be very educative to study the implementation
of <strong class="command">csource</strong>. We should be able to author such
functions ourselves now (a few hours’ worth of work),
let alone read with understanding.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="c1"># compiles a C or C++ source file using R CMD SHLIB,</span>
<span class="c1"># loads the resulting DLL, and executes the embedded R code</span>

<span class="n">csource</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span>
<span class="w">    </span><span class="n">fname</span><span class="p">,</span>
<span class="w">    </span><span class="n">libname</span><span class="o">=</span><span class="kc">NULL</span><span class="p">,</span><span class="w">  </span><span class="c1"># defaults to the base name of `fname` without extension</span>
<span class="w">    </span><span class="n">shlibargs</span><span class="o">=</span><span class="nf">character</span><span class="p">(),</span>
<span class="w">    </span><span class="n">headers</span><span class="o">=</span><span class="nf">paste0</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;#include &lt;R.h&gt;\n&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;#include &lt;Rinternals.h&gt;\n&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;#include &lt;Rmath.h&gt;\n&quot;</span>
<span class="w">    </span><span class="p">),</span>
<span class="w">    </span><span class="n">R</span><span class="o">=</span><span class="nf">file.path</span><span class="p">(</span><span class="nf">R.home</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;bin/R&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">file.exists</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
<span class="w">    </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">shlibargs</span><span class="p">))</span>
<span class="w">    </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">headers</span><span class="p">))</span>
<span class="w">    </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">R</span><span class="p">),</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>

<span class="w">    </span><span class="nf">if </span><span class="p">(</span><span class="nf">is.null</span><span class="p">(</span><span class="n">libname</span><span class="p">))</span>
<span class="w">        </span><span class="n">libname</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">regmatches</span><span class="p">(</span><span class="nf">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
<span class="w">            </span><span class="nf">regexpr</span><span class="p">(</span><span class="s">&quot;[^.]*(?=\\..*)&quot;</span><span class="p">,</span><span class="w"> </span><span class="nf">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span><span class="w"> </span><span class="n">perl</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">))</span>

<span class="w">    </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">is.character</span><span class="p">(</span><span class="n">libname</span><span class="p">),</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">libname</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># read the source file:</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">paste</span><span class="p">(</span><span class="nf">readLines</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span><span class="w"> </span><span class="n">collapse</span><span class="o">=</span><span class="s">&quot;\n&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># set up output file names:</span>
<span class="w">    </span><span class="n">tmpdir</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">normalizePath</span><span class="p">(</span><span class="nf">tempdir</span><span class="p">(),</span><span class="w"> </span><span class="n">winslash</span><span class="o">=</span><span class="s">&quot;/&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># tempdir on Win uses \</span>
<span class="w">    </span><span class="n">dynlib_ext</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">.Platform</span><span class="p">[[</span><span class="s">&quot;dynlib.ext&quot;</span><span class="p">]]</span>
<span class="w">    </span><span class="n">libpath</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">file.path</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="w"> </span><span class="nf">sprintf</span><span class="p">(</span><span class="s">&quot;%s%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">libname</span><span class="p">,</span><span class="w"> </span><span class="n">dynlib_ext</span><span class="p">))</span>
<span class="w">    </span><span class="n">cfname</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">file.path</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="w"> </span><span class="nf">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
<span class="w">    </span><span class="n">rfname</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">sub</span><span class="p">(</span><span class="s">&quot;\\..*?$&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.R&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cfname</span><span class="p">,</span><span class="w"> </span><span class="n">perl</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w">  </span><span class="c1"># .R extension</span>

<span class="w">    </span><span class="c1"># separate the /* R ... &lt;R code&gt; ... R */ chunk from the source file:</span>
<span class="w">    </span><span class="n">rpart</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">regexec</span><span class="p">(</span><span class="s">&quot;(?smi)^/\\* R\\s?(.*)R \\*/$&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">perl</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)[[</span><span class="m">1</span><span class="p">]]</span>
<span class="w">    </span><span class="n">rpart_start</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">rpart</span>
<span class="w">    </span><span class="n">rpart_len</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">attr</span><span class="p">(</span><span class="n">rpart</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;match.length&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nf">if </span><span class="p">(</span><span class="n">rpart_start</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">rpart_len</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="nf">stop</span><span class="p">(</span><span class="s">&quot;enclose R code between /* R ... and ... R */&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="n">rcode</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">substr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">rpart_start</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">rpart_start</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="o">+</span><span class="n">rpart_len</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="m">-1</span><span class="p">)</span>
<span class="w">    </span><span class="nf">cat</span><span class="p">(</span><span class="n">rcode</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="o">=</span><span class="n">rfname</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># write the C/C++ file:</span>
<span class="w">    </span><span class="n">ccode</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">paste</span><span class="p">(</span>
<span class="w">        </span><span class="n">headers</span><span class="p">,</span>
<span class="w">        </span><span class="nf">substr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">rpart_start</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="m">-1</span><span class="p">),</span>
<span class="w">        </span><span class="nf">substr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">rpart_start</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="o">+</span><span class="n">rpart_len</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="nf">nchar</span><span class="p">(</span><span class="n">f</span><span class="p">)),</span>
<span class="w">        </span><span class="n">collapse</span><span class="o">=</span><span class="s">&quot;\n&quot;</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="nf">cat</span><span class="p">(</span><span class="n">ccode</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="o">=</span><span class="n">cfname</span><span class="p">,</span><span class="w"> </span><span class="n">append</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># prepare the &quot;R CMD SHLIB ...&quot; command:</span>
<span class="w">    </span><span class="n">shlibargs</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;CMD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SHLIB&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nf">sprintf</span><span class="p">(</span><span class="s">&quot;-o %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">libpath</span><span class="p">),</span>
<span class="w">        </span><span class="n">cfname</span><span class="p">,</span>
<span class="w">        </span><span class="n">shlibargs</span>
<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="c1"># compile and load the DLL, run the extracted R script:</span>
<span class="w">    </span><span class="n">retval</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">FALSE</span>
<span class="w">    </span><span class="n">oldwd</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">setwd</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
<span class="w">    </span><span class="nf">tryCatch</span><span class="p">({</span>
<span class="w">        </span><span class="nf">if </span><span class="p">(</span><span class="n">libpath</span><span class="w"> </span><span class="o">%in%</span><span class="w"> </span><span class="nf">sapply</span><span class="p">(</span><span class="nf">getLoadedDLLs</span><span class="p">(),</span><span class="w"> </span><span class="n">`[[`</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;path&quot;</span><span class="p">))</span>
<span class="w">            </span><span class="nf">dyn.unload</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
<span class="w">        </span><span class="nf">stopifnot</span><span class="p">(</span><span class="nf">system2</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">shlibargs</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w">  </span><span class="c1"># 0 == success</span>
<span class="w">        </span><span class="nf">dyn.load</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
<span class="w">        </span><span class="nf">source</span><span class="p">(</span><span class="n">rfname</span><span class="p">)</span>
<span class="w">        </span><span class="n">retval</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">TRUE</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="n">error</span><span class="o">=</span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nf">cat</span><span class="p">(</span><span class="nf">as.character</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"> </span><span class="n">file</span><span class="o">=</span><span class="nf">stderr</span><span class="p">())</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="nf">setwd</span><span class="p">(</span><span class="n">oldwd</span><span class="p">)</span>

<span class="w">    </span><span class="nf">if </span><span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span><span class="w"> </span><span class="nf">stop</span><span class="p">(</span><span class="s">&quot;error compiling file or executing R code therein&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="nf">invisible</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div></div></section>
</section>
<section id="handling-basic-types">
<h2><span class="section-number">14.2. </span>Handling basic types<a class="headerlink" href="#handling-basic-types" title="Link to this heading">¶</a></h2>
<section id="sexptypes">
<h3><span class="section-number">14.2.1. </span><code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>s<a class="headerlink" href="#sexptypes" title="Link to this heading">¶</a></h3>
<p>All R objects are stored as instances of the C language structure
<code class="docutils literal notranslate"><span class="pre">SEXPREC</span></code>. Usually, we access them via
pointers, which are of the type <code class="docutils literal notranslate"><span class="pre">SEXP</span></code> (S expression).</p>
<p>A C function referred to via <strong class="command">.Call</strong> takes the very generic
<code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s on input. It outputs another <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>. Importantly,
one of the said structure’s fields represents
the actual R object type (<code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code> numbers);
see <a class="reference internal" href="#tab-sexp-types"><span class="std std-numref">Table 14.1</span></a> for a selection.</p>
<div class="table-wrapper colwidths-given docutils container" id="id37">
<span id="tab-sexp-types"></span><span id="tab-sexp-types"></span><table class="docutils align-default" id="id37">
<caption><span class="caption-number">Table 14.1 </span><span class="caption-text">Basic R types in C.</span><a class="headerlink" href="#id37" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 16.0%" />
<col style="width: 36.0%" />
<col style="width: 48.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong><code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code></strong></p></th>
<th class="head"><p><strong>Type in R</strong> (<strong class="command">typeof</strong>)</p></th>
<th class="head"><p><strong>Test in C</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NILSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NULL</span></code></p></td>
<td><p><strong class="command">Rf_isNull</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code> <em>(true for <code class="docutils literal notranslate"><span class="pre">R_NilValue</span></code> only)</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">RAWSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">raw</span></code></p></td>
<td><p><strong class="command">TYPEOF</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span> <span class="pre">==</span> <span class="pre">RAWSXP</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">LGLSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">logical</span></code></p></td>
<td><p><strong class="command">Rf_isLogical</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INTSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">integer</span></code></p></td>
<td><p><strong class="command">Rf_isInteger</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REALSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p><strong class="command">Rf_isReal</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CPLXSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">complex</span></code></p></td>
<td><p><strong class="command">Rf_isComplex</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">STRSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">character</span></code></p></td>
<td><p><strong class="command">Rf_isString</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">VECSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p><strong class="command">Rf_isVectorList</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code> <em>(scalar string; internal)</em></p></td>
<td><p><strong class="command">TYPEOF</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span> <span class="pre">==</span> <span class="pre">CHARSXP</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EXTPTRSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">externalptr</span></code> <em>(internal)</em></p></td>
<td><p><strong class="command">TYPEOF</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span> <span class="pre">==</span> <span class="pre">EXTPTRSXP</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="proof proof-type-example" id="id38">

    <div class="proof-title">
        <span class="proof-type">Example 14.7</span>
        
    </div><div class="proof-content">
<p>To illustrate that any R object is available as a <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>, consider
the <code class="file docutils literal notranslate"><span class="pre">inst/examples/sexptype.c</span></code> file from <strong class="program">cpackagedemo</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_test_sexptype</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Rprintf</span><span class="p">(</span><span class="s">&quot;type of x: %s (SEXPTYPE=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">Rf_type2char</span><span class="p">(</span><span class="n">TYPEOF</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="w">        </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">TYPEOF</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">test_sexptype &lt;- function(x)</span>
<span class="cm">    invisible(.Call(&quot;C_test_sexptype&quot;, x, PACKAGE=&quot;sexptype&quot;))</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Example calls:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/sexptype.c&quot;</span><span class="p">)</span>
<span class="nf">test_sexptype</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">)</span>
<span class="c1">## type of x: integer (SEXPTYPE=13)</span>
<span class="nf">test_sexptype</span><span class="p">(</span><span class="kc">NA</span><span class="p">)</span>
<span class="c1">## type of x: logical (SEXPTYPE=10)</span>
<span class="nf">test_sexptype</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">)</span>
<span class="c1">## type of x: character (SEXPTYPE=16)</span>
</pre></div>
</div>
<p>We should refer to particular <code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>s
via their descriptive names (constants; e.g., <code class="docutils literal notranslate"><span class="pre">STRSXP</span></code>),
not their numeric identifiers (e.g., 16);
see Section 1.1 of <span id="id11">[<a class="reference internal" href="999-bibliography.html#id13" title="R Development Core Team. (2023).  R Internals. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-ints.html.">68</a>]</span> for the complete list<a class="footnote-reference brackets" href="#footsexptype" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>.</p>
</div></div></section>
<section id="accessing-elements-in-simple-atomic-vectors">
<h3><span class="section-number">14.2.2. </span>Accessing elements in simple atomic vectors<a class="headerlink" href="#accessing-elements-in-simple-atomic-vectors" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="#tab-sexp-array"><span class="std std-numref">Table 14.2</span></a> gives the most important vector-like
<code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>s (atomic and generic), the C types of their elements,
and the functions to access the underlying array pointers.
A call to <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">XLENGTH</strong> returns
the length of a given sequence.</p>
<p>We have already seen an example function that processes a numeric vector;
see <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">my_c_sum_wrapper</strong> above.</p>
<p>Let’s stress that writing functions that accept only <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">double</span></code>
array pointers and their lengths makes them easily reusable in other
environments. In many data analysis applications, we do not need much more.</p>
<div class="table-wrapper colwidths-given docutils container" id="id39">
<span id="tab-sexp-array"></span><span id="tab-sexp-array"></span><table class="docutils align-default" id="id39">
<caption><span class="caption-number">Table 14.2 </span><span class="caption-text">Basic array-like R types and their elements in C.</span><a class="headerlink" href="#id39" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 16.0%" />
<col style="width: 64.0%" />
<col style="width: 20.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong><code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code></strong></p></th>
<th class="head"><p><strong>Array element type</strong></p></th>
<th class="head"><p><strong>Pointer access</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RAWSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">Rbyte;</span></code></p></td>
<td><p><strong class="command">RAW</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">LGLSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code> <em>(use the <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>, <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>, and <code class="docutils literal notranslate"><span class="pre">NA_LOGICAL</span></code> constants)</em></p></td>
<td><p><strong class="command">LOGICAL</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><strong class="command">INTEGER</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REALSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p><strong class="command">REAL</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CPLXSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">typedef</span> <span class="pre">struct</span> <span class="pre">{ double r;</span> <span class="pre">double i; }</span> <span class="pre">Rcomplex;</span></code></p></td>
<td><p><strong class="command">COMPLEX</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">STRSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SEXP</span></code> <em>(array of <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s of the type <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>)</em></p></td>
<td><p><em>(not directly)</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">VECSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SEXP</span></code> <em>(array of <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s of any <code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>)</em></p></td>
<td><p><em>(not directly)</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> <em>(read-only; trailing 0; check encoding)</em></p></td>
<td><p><strong class="command">CHAR</strong><code class="code docutils literal notranslate"><span class="pre">(x)</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>With raw, logical, integer, floating-point, and complex vectors,
we get direct access to data that might be shared amongst many objects
(compare <a class="reference internal" href="330-environment.html#sec-copy-on-demand"><span class="std std-numref">Section 16.1.4</span></a>).
<code class="docutils literal notranslate"><span class="pre">SEXPREC</span></code>s are simply passed by pointers (since <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s are
exactly them). We must thus refrain<a class="footnote-reference brackets" href="#footmod" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>
from modifying the objects passed as function arguments.
Ways to create new vectors, e.g., for storing auxiliary
or return values are discussed below.</p>
</div>
<div class="proof proof-type-example" id="id40">

    <div class="proof-title">
        <span class="proof-type">Example 14.8</span>
        
    </div><div class="proof-content">
<p>Consider <code class="file docutils literal notranslate"><span class="pre">inst/examples/sharedmem.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_test_sharedmem</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be a non-empty vector of the type &#39;double&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// never do it; always make a copy;</span>
<span class="w">            </span><span class="c1">// the underlying array `x` may be shared by many objects</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">test_sharedmem &lt;- function(x)</span>
<span class="cm">    invisible(.Call(&quot;C_test_sharedmem&quot;, x, PACKAGE=&quot;sharedmem&quot;))</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Calling the foregoing function on an example vector:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/sharedmem.c&quot;</span><span class="p">)</span>
<span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">1</span>
<span class="n">z</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">y</span>
<span class="nf">test_sharedmem</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">))</span>
<span class="c1">## [1] 2 2</span>
</pre></div>
</div>
<p>modifies <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> in place! It is not the same semantics as
the one we got used to when interacting with R. Hence, we
must always make a copy.</p>
</div></div></section>
<section id="representation-of-missing-values">
<h3><span class="section-number">14.2.3. </span>Representation of missing values<a class="headerlink" href="#representation-of-missing-values" title="Link to this heading">¶</a></h3>
<p>Most languages do not support the notion of missing values out of the box.
Therefore, in R, they have to be emulated.
<a class="reference internal" href="#tab-sexp-na"><span class="std std-numref">Table 14.3</span></a> lists the relevant constants
and the conventional ways for testing for missingness.</p>
<div class="table-wrapper colwidths-given docutils container" id="id41">
<span id="tab-sexp-na"></span><span id="tab-sexp-na"></span><table class="docutils align-default" id="id41">
<caption><span class="caption-number">Table 14.3 </span><span class="caption-text">Representation of missing values.</span><a class="headerlink" href="#id41" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 16.0%" />
<col style="width: 54.0%" />
<col style="width: 30.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong><code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code></strong></p></th>
<th class="head"><p><strong>Missing value</strong></p></th>
<th class="head"><p><strong>Testing</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">RAWSXP</span></code></p></td>
<td><p><em>(none)</em></p></td>
<td><p><em>(none)</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">LGLSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NA_LOGICAL</span></code> <em>(equal to <code class="docutils literal notranslate"><span class="pre">INT_MIN</span></code>)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">==</span> <span class="pre">NA_LOGICAL</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">INTSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NA_INTEGER</span></code> <em>(equal to <code class="docutils literal notranslate"><span class="pre">INT_MIN</span></code>)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">==</span> <span class="pre">NA_INTEGER</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REALSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NA_REAL</span></code> <em>(a special <code class="docutils literal notranslate"><span class="pre">NaN</span></code>)</em></p></td>
<td><p><strong class="command">ISNA</strong><code class="code docutils literal notranslate"><span class="pre">(el)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CPLXSXP</span></code></p></td>
<td><p>a pair of <code class="docutils literal notranslate"><span class="pre">NA_REAL</span></code>s</p></td>
<td><p><strong class="command">ISNA</strong><code class="code docutils literal notranslate"><span class="pre">(el.r)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">STRSXP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NA_STRING</span></code> <em>(a <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code> object)</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">el</span> <span class="pre">==</span> <span class="pre">NA_STRING</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>In logical and integer vectors, <code class="docutils literal notranslate"><span class="pre">NA</span></code>s are represented
as the smallest 32-bit signed integer. Thus, we need to be careful
when performing any operations on these types:
testing for missingness must be performed first.</p>
<p>The case of <code class="docutils literal notranslate"><span class="pre">double</span></code>s is slightly less irksome, for a missing
value is represented as a special not-a-number.
Many arithmetic operations on <code class="docutils literal notranslate"><span class="pre">NaN</span></code>s
return <code class="docutils literal notranslate"><span class="pre">NaN</span></code>s as well, albeit there is no guarantee<a class="footnote-reference brackets" href="#footnanrepr" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
that they will be of precisely the same type as <code class="docutils literal notranslate"><span class="pre">NA_REAL</span></code>. Thus, manual
testing for missingness is also advised.</p>
<div class="proof proof-type-example" id="id42">

    <div class="proof-title">
        <span class="proof-type">Example 14.9</span>
        
    </div><div class="proof-content">
<p>The <code class="file docutils literal notranslate"><span class="pre">inst/examples/mean_naomit.c</span></code> file defines a function
to compute the arithmetic mean of an <code class="docutils literal notranslate"><span class="pre">int</span></code> or a <code class="docutils literal notranslate"><span class="pre">double</span></code> vector:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_mean_naomit</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rf_isInteger</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NA_INTEGER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// NOT: ISNA(xp[i])</span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">                </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ISNA</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// NOT: xp[i] == NA_REAL</span>
<span class="w">                </span><span class="n">ret</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">                </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be a numeric vector&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarReal</span><span class="p">((</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="p">(</span><span class="n">ret</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">k</span><span class="p">)</span><span class="o">:</span><span class="n">NA_REAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">mean_naomit &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.numeric(x))  # neither integer nor double</span>
<span class="cm">        x &lt;- as.numeric(x)  # convert to double (the same as as.double)</span>
<span class="cm">    .Call(&quot;C_mean_naomit&quot;, x, PACKAGE=&quot;mean_naomit&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>There is some inherent code duplication but <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">double</span></code> are
distinct types. Thus, they need to be handled separately
(we could have convert them to <code class="docutils literal notranslate"><span class="pre">double</span></code>s at the R level too).
Some tests:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/mean_naomit.c&quot;</span><span class="p">)</span>
<span class="nf">mean_naomit</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1L</span><span class="p">,</span><span class="w"> </span><span class="kc">NA_integer_</span><span class="p">,</span><span class="w"> </span><span class="m">3L</span><span class="p">,</span><span class="w"> </span><span class="kc">NA_integer_</span><span class="p">,</span><span class="w"> </span><span class="m">5L</span><span class="p">))</span>
<span class="c1">## [1] 3</span>
<span class="nf">mean_naomit</span><span class="p">(</span><span class="nf">rep</span><span class="p">(</span><span class="kc">NA_real_</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">))</span>
<span class="c1">## [1] NA</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id43">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.10</span>
        
    </div><div class="proof-content">
<p>Implement <strong class="command">all</strong> and <strong class="command">any</strong> in C.
Add the <code class="docutils literal notranslate"><span class="pre">na.rm</span></code> argument.</p>
</div></div></section>
<section id="memory-allocation">
<span id="sec-memory-management"></span><h3><span class="section-number">14.2.4. </span>Memory allocation<a class="headerlink" href="#memory-allocation" title="Link to this heading">¶</a></h3>
<p>R implements a simple yet effective garbage collector that relies
on reference counting. Occasionally<a class="footnote-reference brackets" href="#footgc" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>, memory blocks that can
no longer be reached are either freed or marked as reusable.</p>
<p>To allocate a new vector of length one and set
its only element, we can call
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">ScalarLogical</strong>,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">ScalarInteger</strong>,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">ScalarReal</strong>, etc.
We have already used these functions for returning
R “scalars”.</p>
<p>Vectors of arbitrary lengths can be created using
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_allocVector</strong><code class="code docutils literal notranslate"><span class="pre">(sexptype,</span> <span class="pre">size)</span></code>.
Note that this function does not initialise the elements of
logical and numeric sequences (amongst others). They will need
to be set manually after creation.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>All allocated vectors must be manually protected from garbage collection.
To guard against premature annihilation, R maintains a stack<a class="footnote-reference brackets" href="#footpreserve" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>
of objects. <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">PROTECT</strong><code class="code docutils literal notranslate"><span class="pre">(sexp)</span></code>
pushes a given object pointer onto the top of the list.
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">UNPROTECT</strong><code class="code docutils literal notranslate"><span class="pre">(n)</span></code>
pops the last <em>n</em> elements from it in the last-in-first-out manner.
At the end of a <strong class="command">.Call</strong>, R checks if the number
of protects matches that of unprotects and generates a warning
if there is a stack imbalance.</p>
<p>Protection is <em>not</em> needed:</p>
<ul class="simple">
<li><p>for arguments to functions referred to by  <strong class="command">.Call</strong>,
as they are already in use and hence protected;</p></li>
<li><p>for objects assigned as list or character vectors’ elements
using <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">SET_VECTOR_ELT</strong>
and <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">SET_STRING_ELT</strong>
(see below); when the container is protected, so are its components;</p></li>
<li><p>when we return the allocated vector to R immediately after
creating it (like in <strong class="command">return Rf_ScalarReal</strong><code class="code docutils literal notranslate"><span class="pre">(val)</span></code>
in a C function invoked by <strong class="command">.Call</strong>).</p></li>
</ul>
</div>
<div class="proof proof-type-example" id="id44">

    <div class="proof-title">
        <span class="proof-type">Example 14.11</span>
        
    </div><div class="proof-content">
<p>Here is a function to compute the square of each element
in a numeric vector. Note that the new vector must be protected
from garbage collection while data are being prepared.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_square1</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// no need to call PROTECT(x), it is already in use</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be of the type &#39;double&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">));</span><span class="w">  </span><span class="c1">// won&#39;t be GC&#39;d</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ISNA</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">  </span><span class="c1">// NA_REAL</span>
<span class="w">        </span><span class="k">else</span><span class="w">             </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// pops one object from the protect stack;</span>
<span class="w">        </span><span class="c1">// does not trigger garbage collection, so we can return `y` now</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">  </span><span class="c1">// R will retrieve and protect it</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">square1 &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.double(x)) x &lt;- as.double(x)</span>
<span class="cm">    .Call(&quot;C_square1&quot;, x, PACKAGE=&quot;square1&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>As an alternative, in this case, we may use
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_duplicate</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_square2</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be of the type &#39;double&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_duplicate</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w">  </span><span class="c1">// OK; just replaces the pointer (address)</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ISNA</span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">square2 &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.double(x)) x &lt;- as.double(x)</span>
<span class="cm">    .Call(&quot;C_square2&quot;, x, PACKAGE=&quot;square2&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Some tests:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/square1.c&quot;</span><span class="p">)</span>
<span class="nf">square1</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">-2</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kc">NA_real_</span><span class="p">))</span>
<span class="c1">## [1]  4  1  0  1  4  9 16 NA</span>
<span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/square2.c&quot;</span><span class="p">)</span>
<span class="nf">square2</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">-2</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kc">NA_real_</span><span class="p">))</span>
<span class="c1">## [1]  4  1  0  1  4  9 16 NA</span>
</pre></div>
</div>
</div></div><div style="margin-top: 1em"></div><p>We can claim auxiliary memory from the heap
during a function’s runtime using the well-known
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">malloc</strong> (or <strong class="command">new</strong> in C++).
We are of course fully responsible for releasing it via
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">free</strong> (or <strong class="command">delete</strong>).</p>
<div class="proof proof-type-example" id="id45">

    <div class="proof-title">
        <span class="proof-type">Example 14.12</span>
        
    </div><div class="proof-content">
<p>Here is our version of the <strong class="command">which</strong> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_which1</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isLogical</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be of the type &#39;logical&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOGICAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span><span class="w">  </span><span class="c1">// conservative size</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;memory allocation error&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NA_LOGICAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">            </span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Rf_allocVector can longjmp, memory leak possible...</span>
<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w">  </span><span class="c1">// yes, the type is double; ready for long vectors</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// R uses 1-based indexing</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">which1 &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.logical(x)) x &lt;- as.logical(x)</span>
<span class="cm">    .Call(&quot;C_which1&quot;, x, PACKAGE=&quot;which1&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Some tests:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/which1.c&quot;</span><span class="p">)</span>
<span class="nf">which1</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">))</span>
<span class="c1">## [1] 1 3 5</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id46">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.13</span>
        
    </div><div class="proof-content">
<p>R’s <strong class="command">which</strong> returns either an <code class="docutils literal notranslate"><span class="pre">int</span></code> or a <code class="docutils literal notranslate"><span class="pre">double</span></code> vector, depending
on the size of the input vector (whether it is shorter than <span class="math">\(2^{31}-1\)</span>).
Rewrite the above to take that into account: integer arithmetic is
slightly faster.</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>(*)
R’s exception handling uses a
<a class="reference external" href="https://en.wikipedia.org/wiki/Setjmp.h">long jump</a>.
Therefore, when calling <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_error</strong>
(whether directly or not) normal stack unwinding will not occur.
This is particularly important when using C++ objects which deallocate memory
in their destructors as they might not be invoked whatsoever.</p>
<p>In the preceding example, a call to
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_allocVector</strong> may trigger a long jump,
e.g., if we run out of available memory. In such a case, <code class="docutils literal notranslate"><span class="pre">d</span></code> will
not be freed.</p>
<p>Thus, care should be taken to make sure there are no memory leaks.
We can sometimes switch to
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">R_alloc</strong><code class="code docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">size)</span></code>
which allocates <code class="docutils literal notranslate"><span class="pre">n*size</span></code> bytes. The memory it requests will automatically be
garbage-collected at the end of a <strong class="command">.Call</strong>.</p>
<p>Otherwise, we should ensure that blocks relying on manual memory
allocation are not mixed with the calls to R API functions.
In our <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">which1</strong>, it would be better
to determine the desired size of <code class="docutils literal notranslate"><span class="pre">y</span></code> and allocate it before
calling <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">malloc</strong>.</p>
</div>
<div class="proof proof-type-example" id="id47">

    <div class="proof-title">
        <span class="proof-type">Example 14.14</span>
        
    </div><div class="proof-content">
<p>(*) If we do not like that we are potentially wasting memory
in the case of sparse logical vectors, we can rely on
dynamically growable arrays. Below is a C++ rewrite of the
foregoing function using <code class="docutils literal notranslate"><span class="pre">deque</span></code> (double-ended queue)
from the language’s standard library.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deque&gt;</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">C_which2</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isLogical</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` should be of the type &#39;logical&#39;&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOGICAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// precompute k, Rf_allocVector can do a longjmp</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NA_LOGICAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w">  </span><span class="c1">// ready for long vectors</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">  </span><span class="c1">// allocates memory</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NA_LOGICAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

<span class="w">    </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
<span class="w">        </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// R uses 1-based indexing</span>

<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">  </span><span class="c1">// d&#39;s destructor will be called automatically</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">which2 &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.logical(x)) x &lt;- as.logical(x)</span>
<span class="cm">    .Call(&quot;C_which2&quot;, x, PACKAGE=&quot;which2&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Example calls:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/which2.cpp&quot;</span><span class="p">)</span>
<span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p">(</span><span class="nf">runif</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0.5</span><span class="p">)</span>
<span class="nf">stopifnot</span><span class="p">(</span><span class="nf">which</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">which1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nf">stopifnot</span><span class="p">(</span><span class="nf">which</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nf">which2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Alternatively, we could have used <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">realloc</strong>
to extend an initially small buffer created using
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">malloc</strong> by, say, 50%
whenever it is about to overflow.</p>
</div></div></section>
<section id="lists">
<h3><span class="section-number">14.2.5. </span>Lists<a class="headerlink" href="#lists" title="Link to this heading">¶</a></h3>
<p>For safety reasons<a class="footnote-reference brackets" href="#footrc" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>, we do not get access to the underlying pointers
in lists and character vectors. List items can be read by calling
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">VECTOR_ELT</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">index)</span></code>
and can be set with
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">SET_VECTOR_ELT</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">index,</span> <span class="pre">newval)</span></code>.</p>
<p>Note that lists (<code class="docutils literal notranslate"><span class="pre">VECSXP</span></code>s) are comprised of <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s of any type.
Hence, after extracting an element, its <code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code> needs to be tested
using one of the functions listed in <a class="reference internal" href="#tab-sexp-types"><span class="std std-numref">Table 14.1</span></a>.
This can be tiresome.</p>
<div class="proof proof-type-example" id="id48">

    <div class="proof-title">
        <span class="proof-type">Example 14.15</span>
        
    </div><div class="proof-content">
<p>Here is a rather useless function that fetches the first and
the last element in a given numeric vector or a list.
However, if the latter case, we apply the function recursively
on all its elements.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_firstlast</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isVector</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` must be a non-empty vector (atomic or generic)&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">        </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span><span class="w">             </span><span class="c1">// first</span>
<span class="w">        </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="mi">-1</span><span class="p">];</span><span class="w">  </span><span class="c1">// last</span>
<span class="w">        </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Rf_isVectorList</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">VECSXP</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">        </span><span class="c1">// VECTOR_ELT(x, i) is PROTECTed by the container;</span>
<span class="w">        </span><span class="c1">// SET_VECTOR_ELT does not trigger GC; no need to call PROTECT</span>
<span class="w">        </span><span class="c1">// on the result of C_firstlast(...) in this context</span>
<span class="w">        </span><span class="n">SET_VECTOR_ELT</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">C_firstlast</span><span class="p">(</span><span class="n">VECTOR_ELT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)));</span>
<span class="w">        </span><span class="n">SET_VECTOR_ELT</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">C_firstlast</span><span class="p">(</span><span class="n">VECTOR_ELT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="mi">-1</span><span class="p">)));</span>
<span class="w">        </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;other cases left as an exercise&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">;</span><span class="w">  </span><span class="c1">// avoid compiler warning</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">firstlast &lt;- function(x)</span>
<span class="cm">    .Call(&quot;C_firstlast&quot;, x, PACKAGE=&quot;firstlast&quot;)</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Testing:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/firstlast.c&quot;</span><span class="p">)</span>
<span class="nf">firstlast</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">))</span>
<span class="c1">## [1] 1 3</span>
<span class="nf">firstlast</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">),</span><span class="w"> </span><span class="m">6</span><span class="p">))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] 1 3</span>
<span class="c1">##</span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] 6 6</span>
<span class="nf">firstlast</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="p">))))</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] 1 3</span>
<span class="c1">##</span>
<span class="c1">## [[2]]</span>
<span class="c1">## [[2]][[1]]</span>
<span class="c1">## [1] 6 6</span>
<span class="c1">##</span>
<span class="c1">## [[2]][[2]]</span>
<span class="c1">## [1]  9 11</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id49">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.16</span>
        
    </div><div class="proof-content">
<p>Implement a C function that returns the longest vector in a given list.
Use <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_isVector</strong>
to check whether a given object is an atomic or a generic vector,
and hence if <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">XLENGTH</strong>
can be called thereon.</p>
</div></div><div class="proof proof-type-exercise" id="id50">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.17</span>
        
    </div><div class="proof-content">
<p>Inscribe your version of <strong class="command">unlist</strong>.
Consider scanning the input list twice.
First, determine the size of the output vector.
Second, fill the return object with the un-listed values.</p>
</div></div><div class="proof proof-type-exercise" id="id51">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.18</span>
        
    </div><div class="proof-content">
<p>Write a C function that takes a list of numeric vectors
of identical lengths. Return their elementwise sum:
the first element of the output should be the sum of the first
elements in every input vector, and so forth.</p>
</div></div></section>
<section id="character-vectors-and-individual-strings">
<h3><span class="section-number">14.2.6. </span>Character vectors and individual strings (*)<a class="headerlink" href="#character-vectors-and-individual-strings" title="Link to this heading">¶</a></h3>
<p>Character vectors (<code class="docutils literal notranslate"><span class="pre">STRSXP</span></code>s) are similar to <code class="docutils literal notranslate"><span class="pre">VECSXP</span></code>s
except that they only carry individual strings which are
represented using a separate data type, <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>.
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">STRING_ELT</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">index)</span></code> and
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">SET_STRING_ELT</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">index,</span> <span class="pre">newval)</span></code>
play the role of the element getters and setters.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If we are not interested in text processing but rather in
handling <em>categorical</em> data or defining grouping variables,
we should consider converting character vectors to <em>factors</em>
before issuing a <strong class="command">.Call</strong>.
Comparing small integers is much faster than strings;
see below for more details.</p>
</div>
<p>Because of R’s string cache, there are no duplicate strings
in the memory. However, this feature could only be guaranteed
by making data in <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>s <em>read-only</em>. We can access
the underlying <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> pointer by calling
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">CHAR</strong><code class="code docutils literal notranslate"><span class="pre">(s)</span></code>.
As typical in C, a string is terminated by byte 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>R strings may be of different encodings; compare
<a class="reference internal" href="160-character.html#sec-string-input-repr"><span class="std std-numref">Section 6.1.1</span></a>. For portability
and peace of mind, it is best to preprocess the arguments to
<strong class="command">.Call</strong> using <strong class="command">enc2utf8</strong>, which
converts all strings to UTF-8<a class="footnote-reference brackets" href="#footrprintf" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.</p>
<p>Despite being the most universal encoding, UTF-8 does not
represent each code point using a fixed number of bytes.
For instance, computing the string length
requires iterating over all its elements. For <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>s,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">XLENGTH</strong> returns the number
of <em>bytes</em>, not including the trailing 0.</p>
<p>It is thus best to leave the processing of strings to the
dedicated libraries, e.g., <a class="reference external" href="https://icu.unicode.org/">ICU</a>
or rely on functions from the <strong class="program">stringi</strong>
package <span id="id19">[<a class="reference internal" href="999-bibliography.html#id6" title="Gagolewski, M. (2022).  stringi: Fast and portable character string processing in R. Journal of Statistical Software, 103(2):1–59. URL: https://stringi.gagolewski.com/, DOI: 10.18637/jss.v103.i02.">26</a>]</span> at the R level.</p>
</div>
<p>C strings can be converted to <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>s by calling
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_mkCharCE</strong><code class="code docutils literal notranslate"><span class="pre">(stringbuf,</span> <span class="pre">CE_UTF8)</span></code>
or
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_mkCharLenCE</strong><code class="code docutils literal notranslate"><span class="pre">(stringbuf,</span> <span class="pre">buflen,</span> <span class="pre">CE_UTF8)</span></code>.
If we are sure that a string is in ASCII (a subset of UTF-8),
we can also call <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_mkChar</strong><code class="code docutils literal notranslate"><span class="pre">(stringbuf)</span></code>.</p>
<p>We should never return <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code>s as results to R. They are
for internal use only. They must be wrapped inside a character vector,
e.g., using <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_ScalarString</strong>.</p>
</section>
<section id="calling-r-functions-from-c">
<h3><span class="section-number">14.2.7. </span>Calling R functions from C (**)<a class="headerlink" href="#calling-r-functions-from-c" title="Link to this heading">¶</a></h3>
<p>Section 5.11 of <span id="id20">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span> discusses ways to call R functions in C.
To understand them, we will first need to study the material
from the remaining chapters of our book,
i.e., environments and the related evaluation model.
They can be useful, e.g., when calling optimisation algorithms
implemented in C on objective functions written in R.</p>
</section>
<section id="external-pointers">
<span id="sec-xptr"></span><h3><span class="section-number">14.2.8. </span>External pointers (**)<a class="headerlink" href="#external-pointers" title="Link to this heading">¶</a></h3>
<p>For storing arbitrary C pointers, there is a separate basic R type
named <code class="docutils literal notranslate"><span class="pre">externalptr</span></code> (<code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code> of <code class="docutils literal notranslate"><span class="pre">EXTPTRSXP</span></code>);
see Section 5.13 of <span id="id21">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span> for more details.</p>
<p>We can use them to maintain dynamic data structures
or resource handlers between calls to R functions.
The problem with these is that pointers are passed as… pointers.
They can easily break R’s pass-by-value-like semantics,
where changes to the state of the referenced object will
be visible outside the call.</p>
<p>Furthermore, pointers are not serialisable. They cannot be saved
for use in another R session.</p>
<div class="proof proof-type-example" id="id52">

    <div class="proof-title">
        <span class="proof-type">Example 14.19</span>
        
    </div><div class="proof-content">
<p>(**) <code class="file docutils literal notranslate"><span class="pre">inst/examples/stack.cpp</span></code> provides a C++ implementation
of the stack data structure, being a last-in-first-out container
of arbitrary R objects:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deque&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">SEXP</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span><span class="o">~</span><span class="n">S</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span><span class="w">   </span><span class="c1">// destructor: release all SEXPs so that they can be GC&#39;d</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">SEXP</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">();</span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pop_front</span><span class="p">();</span>
<span class="w">            </span><span class="n">R_ReleaseObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="nf">get_stack_pointer</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">check_zero</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span><span class="w">  </span><span class="c1">// internal function</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TYPEOF</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EXTPTRSXP</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;not an external pointer&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_ExternalPtrTag</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">  </span><span class="c1">// our convention, this can be anything</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TYPEOF</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CHARSXP</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">strcmp</span><span class="p">(</span><span class="n">CHAR</span><span class="p">(</span><span class="n">tag</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;stack&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;not a stack&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="p">)</span><span class="n">R_ExternalPtrAddr</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">check_zero</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">sp</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;address is 0&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">stack_finaliser</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">  </span><span class="c1">// internal function</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// called during garbage collection</span>
<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_stack_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span><span class="w">  </span><span class="c1">// destruct S, release SEXPs</span>
<span class="w">        </span><span class="n">R_ClearExternalPtr</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">C_stack_create</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">S</span><span class="p">();</span><span class="w">  </span><span class="c1">// stack pointer</span>
<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span>
<span class="w">        </span><span class="n">R_MakeExternalPtr</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="cm">/*tag*/</span><span class="n">mkChar</span><span class="p">(</span><span class="s">&quot;stack&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">R_RegisterCFinalizerEx</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">stack_finaliser</span><span class="p">,</span><span class="w"> </span><span class="n">TRUE</span><span class="p">);</span><span class="w">  </span><span class="c1">// auto-called on GC</span>
<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">C_stack_empty</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_stack_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarLogical</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">C_stack_push</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_stack_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="n">R_PreserveObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">push_front</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">R_NilValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">C_stack_pop</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">S</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_stack_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;stack is empty&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">();</span>
<span class="w">    </span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pop_front</span><span class="p">();</span>
<span class="w">    </span><span class="n">R_ReleaseObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">stack_create &lt;- function()</span>
<span class="cm">    .Call(&quot;C_stack_create&quot;, PACKAGE=&quot;stack&quot;)</span>

<span class="cm">stack_empty &lt;- function(s)</span>
<span class="cm">    .Call(&quot;C_stack_empty&quot;, s, PACKAGE=&quot;stack&quot;)</span>

<span class="cm">stack_push &lt;- function(s, obj)</span>
<span class="cm">    .Call(&quot;C_stack_push&quot;, s, obj, PACKAGE=&quot;stack&quot;)</span>

<span class="cm">stack_pop &lt;- function(s)</span>
<span class="cm">    .Call(&quot;C_stack_pop&quot;, s, PACKAGE=&quot;stack&quot;)</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Note how we preserve R objects from garbage collection.
Some tests:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/stack.cpp&quot;</span><span class="p">)</span>
<span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">stack_create</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">## &lt;pointer: 0x560958a90550&gt;</span>
<span class="nf">typeof</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">## [1] &quot;externalptr&quot;</span>
<span class="nf">for </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Spanish Inquisition&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="nf">stack_push</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="nf">while </span><span class="p">(</span><span class="o">!</span><span class="nf">stack_empty</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="w">    </span><span class="nf">print</span><span class="p">(</span><span class="nf">stack_pop</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="c1">## [1] &quot;Spanish Inquisition&quot;</span>
<span class="c1">## [1] &quot;two&quot;</span>
<span class="c1">## [1] &quot;one&quot;</span>
</pre></div>
</div>
</div></div></section>
</section>
<section id="dealing-with-compound-types">
<h2><span class="section-number">14.3. </span>Dealing with compound types<a class="headerlink" href="#dealing-with-compound-types" title="Link to this heading">¶</a></h2>
<section id="reading-and-setting-attributes">
<h3><span class="section-number">14.3.1. </span>Reading and setting attributes<a class="headerlink" href="#reading-and-setting-attributes" title="Link to this heading">¶</a></h3>
<p>From <a class="reference internal" href="220-s3.html#chap-s3"><span class="std std-numref">Chapter 10</span></a>, we know that compound types
such as matrices, factors, or data frames are
represented using basic data structures.
Usually, they are atomic vectors or lists organised in a predefined manner.</p>
<p><strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_getAttrib</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">attrname)</span></code> and
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_setAttrib</strong><code class="code docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">attrname,</span> <span class="pre">newval)</span></code>
gets and sets specific attributes of an object <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Their second argument, <code class="docutils literal notranslate"><span class="pre">attrname</span></code>, should be a one-element <code class="docutils literal notranslate"><span class="pre">STRSXP</span></code>.
For convenience, the constants
<code class="docutils literal notranslate"><span class="pre">R_ClassSymbol</span></code>,
<code class="docutils literal notranslate"><span class="pre">R_DimNamesSymbol</span></code>,
<code class="docutils literal notranslate"><span class="pre">R_DimSymbol</span></code>,
<code class="docutils literal notranslate"><span class="pre">R_LevelsSymbol</span></code>,
<code class="docutils literal notranslate"><span class="pre">R_NamesSymbol</span></code>, and
<code class="docutils literal notranslate"><span class="pre">R_RowNamesSymbol</span></code> can be used instead of
the <code class="docutils literal notranslate"><span class="pre">STRSXP</span></code> versions of the
<code class="docutils literal notranslate"><span class="pre">&quot;class&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;dimnames&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;dim&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;levels&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;names&quot;</span></code>, and
<code class="docutils literal notranslate"><span class="pre">&quot;row.names&quot;</span></code> strings.</p>
<div class="proof proof-type-example" id="id53">

    <div class="proof-title">
        <span class="proof-type">Example 14.20</span>
        
    </div><div class="proof-content">
<p>Consider a function for testing whether an object
is of a given class:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="n">SEXP</span><span class="w"> </span><span class="nf">C_isofclass</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">SEXP</span><span class="w"> </span><span class="n">class</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isString</span><span class="p">(</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`class` must be a single string&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">OBJECT</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w">  </span><span class="c1">// is the class attribute set at all?</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarLogical</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">xclass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rf_getAttrib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">R_ClassSymbol</span><span class="p">);</span><span class="w">  </span><span class="c1">// STRSXP (guaranteed)</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CHAR</span><span class="p">(</span><span class="n">STRING_ELT</span><span class="p">(</span><span class="n">class</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">  </span><span class="c1">// class arg as a C string</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">xclass</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">CHAR</span><span class="p">(</span><span class="n">STRING_ELT</span><span class="p">(</span><span class="n">xclass</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)),</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarLogical</span><span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Rf_ScalarLogical</span><span class="p">(</span><span class="n">FALSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">isofclass &lt;- function(x, class)</span>
<span class="cm">    .Call(&quot;C_isofclass&quot;, x, class, PACKAGE=&quot;isofclass&quot;)</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Some tests:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/isofclass.c&quot;</span><span class="p">)</span>
<span class="nf">isofclass</span><span class="p">(</span><span class="nf">Sys.time</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;POSIXct&quot;</span><span class="p">)</span>
<span class="c1">## [1] TRUE</span>
<span class="nf">isofclass</span><span class="p">(</span><span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">15</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;matrix&quot;</span><span class="p">)</span>
<span class="c1">## [1] FALSE</span>
</pre></div>
</div>
<p>Note that a matrix has an <em>implicit</em> class (reported by
the <strong class="command">class</strong> function), but its <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute does
not have to be set. Hence the negative result.</p>
</div></div><div class="proof proof-type-example" id="id54">

    <div class="proof-title">
        <span class="proof-type">Example 14.21</span>
        
    </div><div class="proof-content">
<p>Write a function that fetches a particular <em>named</em> element
in a list.</p>
</div></div></section>
<section id="factors">
<h3><span class="section-number">14.3.2. </span>Factors<a class="headerlink" href="#factors" title="Link to this heading">¶</a></h3>
<p>Factors (<a class="reference internal" href="220-s3.html#sec-factor"><span class="std std-numref">Section 10.3.2</span></a>) are represented as integer vectors
with elements in the set {1, 2, …, <em>k</em>, <code class="docutils literal notranslate"><span class="pre">NA_integer_</span></code>}
for some <em>k</em>. They are equipped with the <code class="docutils literal notranslate"><span class="pre">levels</span></code> attribute,
being a character vector of length <em>k</em>. Their <code class="docutils literal notranslate"><span class="pre">class</span></code>
attribute is set to <code class="docutils literal notranslate"><span class="pre">factor</span></code>.</p>
<div class="proof proof-type-example" id="id55">

    <div class="proof-title">
        <span class="proof-type">Example 14.22</span>
        
    </div><div class="proof-content">
<p>An example implementation of a function to compute the number
of occurrences of each factor level is given below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_table1</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isFactor</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` is not a &#39;factor&#39; object&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">  </span><span class="c1">// `x` is INTSXP</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">levels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rf_getAttrib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">R_LevelsSymbol</span><span class="p">);</span><span class="w">  </span><span class="c1">// `levels` is a STRSXP</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">levels</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NA_INTEGER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">                </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;malformed factor&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// better safe than sorry</span>
<span class="w">            </span><span class="n">yp</span><span class="p">[</span><span class="n">xp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">  </span><span class="c1">// levels are 1..k, but C needs 0..k-1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Rf_setAttrib</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">R_NamesSymbol</span><span class="p">,</span><span class="w"> </span><span class="n">levels</span><span class="p">);</span><span class="w">  </span><span class="c1">// set names attribute</span>
<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">table1 &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.factor(x)) x &lt;- as.factor(x)</span>
<span class="cm">    .Call(&quot;C_table1&quot;, x, PACKAGE=&quot;table1&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Testing:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/table1.c&quot;</span><span class="p">)</span>
<span class="nf">table1</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bacon&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">NA</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;eggs&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bacon&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spam&quot;</span><span class="p">))</span>
<span class="c1">## bacon  eggs  spam</span>
<span class="c1">##     2     1     4</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id56">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.23</span>
        
    </div><div class="proof-content">
<p>Create a function to compute the most frequently occurring
value (mode) in a given factor. Return a character vector.
If a mode is ambiguous, return all the possible candidates.</p>
</div></div></section>
<section id="matrices">
<h3><span class="section-number">14.3.3. </span>Matrices<a class="headerlink" href="#matrices" title="Link to this heading">¶</a></h3>
<p>Matrices (<a class="reference internal" href="230-matrix.html#chap-matrix"><span class="std std-numref">Chapter 11</span></a>) are <em>flat</em> atomic vectors or lists with
the <code class="docutils literal notranslate"><span class="pre">dim</span></code> attribute being a vector of length two.
The <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute does not have to be set
(but the <strong class="command">class</strong> function returns <code class="docutils literal notranslate"><span class="pre">matrix</span></code> and <code class="docutils literal notranslate"><span class="pre">array</span></code>).</p>
<p>Matrices are so important in data analysis that they have been blessed
with a few dedicated functions available at the C level.
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_isMatrix</strong> tests if a given
object meets the criteria mentioned above.</p>
<p>R relies on the Fortran order of matrix elements, i.e.,
it uses the column-major alignment. Let <code class="docutils literal notranslate"><span class="pre">A</span></code> be a matrix
with <em>n</em> rows and <em>m</em> columns
(compare <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_nrows</strong>
and <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_ncols</strong>).
Then, the element in the <em>i</em>-th row
and the <em>j</em>-th column is at <code class="docutils literal notranslate"><span class="pre">A[i+n*j]</span></code>.</p>
<p><strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rf_allocMatrix</strong><code class="code docutils literal notranslate"><span class="pre">(sexptype,</span> <span class="pre">n,</span> <span class="pre">m)</span></code>
allocates a new matrix. The <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> attributes must be handled
manually, though.</p>
<div class="proof proof-type-example" id="id57">

    <div class="proof-title">
        <span class="proof-type">Example 14.24</span>
        
    </div><div class="proof-content">
<p>Here is a function to compute the transpose of a numeric matrix:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_transpose</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isMatrix</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">Rf_isReal</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`x` must be a real matrix&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rf_nrows</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rf_ncols</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">xp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocMatrix</span><span class="p">(</span><span class="n">REALSXP</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">));</span>
<span class="w">    </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REAL</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">            </span><span class="n">yp</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="n">j</span><span class="p">];</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">dimnames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rf_getAttrib</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">R_DimNamesSymbol</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isNull</span><span class="p">(</span><span class="n">dimnames</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SEXP</span><span class="w"> </span><span class="n">tdimnames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">VECSXP</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">        </span><span class="n">SET_VECTOR_ELT</span><span class="p">(</span><span class="n">tdimnames</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">VECTOR_ELT</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">        </span><span class="n">SET_VECTOR_ELT</span><span class="p">(</span><span class="n">tdimnames</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">VECTOR_ELT</span><span class="p">(</span><span class="n">dimnames</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">        </span><span class="n">Rf_setAttrib</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">R_DimNamesSymbol</span><span class="p">,</span><span class="w"> </span><span class="n">tdimnames</span><span class="p">);</span><span class="w">  </span><span class="c1">// set dimnames</span>
<span class="w">        </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// dimnames may have the names attribute too (left as an exercise)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">transpose &lt;- function(x)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.matrix(x)) x &lt;- as.matrix(x)</span>
<span class="cm">    if (!is.double(x)) x[] &lt;- as.double(x)  # preserves attributes</span>
<span class="cm">    .Call(&quot;C_transpose&quot;, x, PACKAGE=&quot;transpose&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Testing:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/transpose.c&quot;</span><span class="p">)</span>
<span class="nf">transpose</span><span class="p">(</span><span class="nf">cbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="c1">## [2,]    5    6    7    8</span>
<span class="nf">transpose</span><span class="p">(</span><span class="n">Titanic</span><span class="p">[,</span><span class="w"> </span><span class="s">&quot;Male&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Adult&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">])</span>
<span class="c1">##     1st 2nd 3rd Crew</span>
<span class="c1">## No  118 154 387  670</span>
<span class="c1">## Yes  57  14  75  192</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id58">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.25</span>
        
    </div><div class="proof-content">
<p>Author a C function named <strong class="command">table2</strong> that computes a two-way
contingency table.</p>
</div></div></section>
<section id="data-frames">
<h3><span class="section-number">14.3.4. </span>Data frames<a class="headerlink" href="#data-frames" title="Link to this heading">¶</a></h3>
<p>Data frames (<a class="reference internal" href="240-data-frame.html#chap-data-frame"><span class="std std-numref">Chapter 12</span></a>) are lists of <em>m</em> vectors
of identical lengths <em>n</em> or matrices of <em>n</em> rows for some <em>n</em> and <em>m</em>.
The character vectors stored in the <code class="docutils literal notranslate"><span class="pre">row.names</span></code> and <code class="docutils literal notranslate"><span class="pre">names</span></code> attributes
give the <em>n</em> row and <em>m</em> column labels. They are objects of the S3 class
<code class="docutils literal notranslate"><span class="pre">data.frame</span></code>.</p>
<p>We process data frames as ordinary lists. However, assuming we only want to
process numeric data, we can extract the quantitative columns and put
them inside a matrix <em>at the R level</em>. If element grouping is required,
they can be accompanied by a factor or a list of factor variables.
In many applications, this strategy is good enough.</p>
</section>
</section>
<section id="using-existing-function-libraries">
<h2><span class="section-number">14.4. </span>Using existing function libraries<a class="headerlink" href="#using-existing-function-libraries" title="Link to this heading">¶</a></h2>
<section id="checking-for-user-interrupts">
<h3><span class="section-number">14.4.1. </span>Checking for user interrupts<a class="headerlink" href="#checking-for-user-interrupts" title="Link to this heading">¶</a></h3>
<p>Long computations may lead to R’s becoming unresponsive.
The user may always request to cancel the evaluation of
the current expression by pressing <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>+<kbd class="kbd docutils literal notranslate">C</kbd></kbd>.</p>
<p>To process the event queue, we should occasionally call
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">R_CheckUserInterrupt</strong><code class="code docutils literal notranslate"><span class="pre">()</span></code>,
e.g., in every iteration of a complex <code class="docutils literal notranslate"><span class="pre">for</span></code> loop.
Note that R might decide never to return to our function.
Thus, we have to prevent memory leaks, e.g.,
by preferring <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">R_alloc</strong>
over <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">malloc</strong>.</p>
</section>
<section id="generating-pseudorandom-numbers">
<h3><span class="section-number">14.4.2. </span>Generating pseudorandom numbers<a class="headerlink" href="#generating-pseudorandom-numbers" title="Link to this heading">¶</a></h3>
<p><strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">unif_rand</strong> returns
a single pseudorandom deviate from the uniform distribution
on the unit interval. It is the basis for generating numbers
from all other supported distributions (Section 6.7.1 of <span id="id22">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>).</p>
<p>It uses the same pseudorandom generator as we described
in <a class="reference internal" href="120-numeric.html#sec-pseudorandom"><span class="std std-numref">Section 2.1.5</span></a>. To read and memorise
its seed (the `<code class="docutils literal notranslate"><span class="pre">.Random.seed</span></code>` object in the global environment),
we have to call
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">GetRNGstate</strong><code class="code docutils literal notranslate"><span class="pre">()</span></code> and
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">PutRNGstate</strong><code class="code docutils literal notranslate"><span class="pre">()</span></code>
at the beginning and the end of our function, respectively.</p>
<div class="proof proof-type-example" id="id59">

    <div class="proof-title">
        <span class="proof-type">Example 14.26</span>
        
    </div><div class="proof-content">
<p>Below is a function to generate a pseudorandom bit sequence:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SEXP</span><span class="w"> </span><span class="nf">C_randombits</span><span class="p">(</span><span class="n">SEXP</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Rf_isInteger</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">XLENGTH</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;`n` should be a single integer&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NA_INTEGER</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">_n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rf_error</span><span class="p">(</span><span class="s">&quot;incorrect `n`&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">SEXP</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROTECT</span><span class="p">(</span><span class="n">Rf_allocVector</span><span class="p">(</span><span class="n">INTSXP</span><span class="p">,</span><span class="w"> </span><span class="n">_n</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">yp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INTEGER</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="w">    </span><span class="n">GetRNGstate</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">_n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">yp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">unif_rand</span><span class="p">()</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">);</span><span class="w">  </span><span class="c1">// not the best way to sample bits</span>
<span class="w">    </span><span class="n">PutRNGstate</span><span class="p">();</span>

<span class="w">    </span><span class="n">UNPROTECT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* R</span>
<span class="cm">randombits &lt;- function(n)</span>
<span class="cm">{</span>
<span class="cm">    if (!is.integer(n)) n &lt;- as.integer(n)</span>
<span class="cm">    .Call(&quot;C_randombits&quot;, n, PACKAGE=&quot;randombits&quot;)</span>
<span class="cm">}</span>
<span class="cm">R */</span>
</pre></div>
</div>
<p>Let’s play around with it:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">csource</span><span class="p">(</span><span class="s">&quot;~/R/cpackagedemo/inst/examples/randombits.c&quot;</span><span class="p">)</span>
<span class="nf">set.seed</span><span class="p">(</span><span class="m">123</span><span class="p">);</span><span class="w"> </span><span class="nf">randombits</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="c1">##  [1] 0 1 0 1 1 0 1 1 1 0</span>
<span class="nf">randombits</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
<span class="c1">##  [1] 1 0 1 1 0 1 0 0 0 1</span>
<span class="nf">set.seed</span><span class="p">(</span><span class="m">123</span><span class="p">);</span><span class="w"> </span><span class="nf">randombits</span><span class="p">(</span><span class="m">20</span><span class="p">)</span>
<span class="c1">##  [1] 0 1 0 1 1 0 1 1 1 0 1 0 1 1 0 1 0 0 0 1</span>
<span class="nf">set.seed</span><span class="p">(</span><span class="m">123</span><span class="p">);</span><span class="w"> </span><span class="nf">as.integer</span><span class="p">(</span><span class="nf">runif</span><span class="p">(</span><span class="m">20</span><span class="p">)</span><span class="o">&gt;</span><span class="m">0.5</span><span class="p">)</span><span class="w">  </span><span class="c1"># it&#39;s the same &quot;algorithm&quot;</span>
<span class="c1">##  [1] 0 1 0 1 1 0 1 1 1 0 1 0 1 1 0 1 0 0 0 1</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id60">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.27</span>
        
    </div><div class="proof-content">
<p>Create a function to compute the most frequently occurring
value (mode) in a given factor object.
In the case of ambiguity, return a randomly chosen candidate.</p>
</div></div></section>
<section id="mathematical-functions-from-the-r-api">
<h3><span class="section-number">14.4.3. </span>Mathematical functions from the R API<a class="headerlink" href="#mathematical-functions-from-the-r-api" title="Link to this heading">¶</a></h3>
<p>Section 6.7 of <span id="id23">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>
lists the available statistical distribution functions,
mathematical routines and constants, and other numerical
utilities.</p>
</section>
<section id="header-files-from-other-r-packages">
<h3><span class="section-number">14.4.4. </span>Header files from other R packages (*)<a class="headerlink" href="#header-files-from-other-r-packages" title="Link to this heading">¶</a></h3>
<p>A package may use header files from another package.
For this to be possible, it must include the dependency name
in the <code class="docutils literal notranslate"><span class="pre">LinkingTo</span></code> field of its <code class="file docutils literal notranslate"><span class="pre">DESCRIPTION</span></code> file;
see <span id="id24">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span> for discussion.</p>
<div class="proof proof-type-exercise" id="id61">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.28</span>
        
    </div><div class="proof-content">
<p>The <strong class="program">BH</strong> package on CRAN gives access to Boost,
the header-only C++ libraries that define many useful algorithms
and data structures. Create an R package that calls
<strong class="program">C++</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="program">boost</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="program">math</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">gcd</strong> after issuing
the <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;boost/math/common_factor.hpp&gt;</span></code> directive.</p>
</div></div></section>
<section id="specifying-compiler-and-linker-flags">
<h3><span class="section-number">14.4.5. </span>Specifying compiler and linker flags (**)<a class="headerlink" href="#specifying-compiler-and-linker-flags" title="Link to this heading">¶</a></h3>
<p>We can pass arbitrary flags to the compiler or linker,
e.g., to use any library installed on our system.</p>
<p>Basic configuration can be tweaked via <code class="file docutils literal notranslate"><span class="pre">Makevars</span></code>
(or <code class="file docutils literal notranslate"><span class="pre">Makevars.win</span></code> on W****ws), e.g.,
by setting <code class="docutils literal notranslate"><span class="pre">PKG_CFLAGS</span></code> or <code class="docutils literal notranslate"><span class="pre">PKG_LIBS</span></code> variables.</p>
<p>For maximum portability across different platforms,
which is overall challenging to ensure if we do not wish to exclude
W****ws users, we might be required to author custom
<code class="file docutils literal notranslate"><span class="pre">configure</span></code> (and <code class="file docutils literal notranslate"><span class="pre">configure.win</span></code>) scripts.</p>
<p>For more information, see <span id="id25">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span>. In particular,
it discusses how to use OpenMP<a class="footnote-reference brackets" href="#footopenmp" id="id26" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a> in our projects.</p>
</section>
</section>
<section id="exercises">
<h2><span class="section-number">14.5. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">¶</a></h2>
<div class="proof proof-type-exercise" id="id62">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.29</span>
        
    </div><div class="proof-content">
<p>Answer the following questions about the C language API for R.</p>
<ul class="simple">
<li><p>What are the most common <code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>s?</p></li>
<li><p>How are missing values represented?</p></li>
<li><p>How can we check if an <code class="docutils literal notranslate"><span class="pre">int</span></code> is a missing value?
What about a <code class="docutils literal notranslate"><span class="pre">double</span></code>?</p></li>
<li><p>How to prevent <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>s from being garbage-collected?</p></li>
<li><p>How are character vectors represented?
What is the difference between a <code class="docutils literal notranslate"><span class="pre">CHARSXP</span></code> and a <code class="docutils literal notranslate"><span class="pre">STRSXP</span></code>?</p></li>
<li><p>Why is it better to handle factor objects rather than raw character
vectors if we merely would like to define grouping variables?</p></li>
<li><p>How are R matrices represented in C? Does R use the C or Fortran order
of matrix elements?</p></li>
<li><p>How are R data frames handled in C?</p></li>
</ul>
</div></div><div class="proof proof-type-exercise" id="id63">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.30</span>
        
    </div><div class="proof-content">
<p>Implement the C versions of the
<strong class="command">rep</strong>,
<strong class="command">seq</strong>,
<strong class="command">rle</strong>,
<strong class="command">match</strong>,
<strong class="command">findInterval</strong>,
<strong class="command">sample</strong>,
<strong class="command">order</strong>,
<strong class="command">unique</strong>, and
<strong class="command">split</strong> functions.</p>
</div></div><div class="proof proof-type-exercise" id="id64">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.31</span>
        
    </div><div class="proof-content">
<p>(*) Read <em>Writing R Extensions</em> <span id="id27">[<a class="reference internal" href="999-bibliography.html#id15" title="R Development Core Team. (2023).  Writing R Extensions. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-exts.html.">65</a>]</span> in its entirety.</p>
</div></div><div class="proof proof-type-exercise" id="id65">

    <div class="proof-title">
        <span class="proof-type">Exercise 14.32</span>
        
    </div><div class="proof-content">
<p>(*) Download R’s source code from <a class="reference external" href="https://stat.ethz.ch/R/daily">CRAN</a>
or its <a class="reference external" href="https://svn.r-project.org/R/trunk"><strong class="program">Subversion</strong></a> (SVN)
repository. Explore the header files in
the <code class="file docutils literal notranslate"><span class="pre">src/include</span></code> subdirectory. They are part of the callable API.</p>
</div></div><hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footlangs" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Plain C and C++ are as fast as we can get without applying
fancy CPU-specific optimisations or similar hacks. Fortran is also
supported but will not be covered in this book because of its smaller
popularity. Additionally, certain external packages are gateways to other
languages, such as Java.</p>
<p>Nevertheless, D.E. Knuth once said: “The real problem is
that programmers have spent far too much time worrying
about efficiency in the wrong places and at the wrong times;
premature optimisation is the root of all
evil (or at least most of it) in programming” <span id="id28">[<a class="reference internal" href="999-bibliography.html#id74" title="Knuth, D.E. (1974).  Computer programming as an art. Communications of the ACM, 17(12):667–673. URL: https://www.cs.tufts.edu/~nr/cs257/archive/don-knuth/as-an-art.pdf.">39</a>]</span>.</p>
</aside>
<aside class="footnote brackets" id="rcpp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">2</a><span class="fn-bracket">]</span></span>
<p>Hence, we are not interested in the overall very
convenient <strong class="program">Rcpp</strong> or <strong class="program">cpp11</strong> packages.
They define C++ classes that make interacting
with R objects more pleasant for some users.</p>
</aside>
<aside class="footnote brackets" id="noaltrep" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">3</a><span class="fn-bracket">]</span></span>
<p>Thus, we will not discuss the ALTREP <span id="id29">[<a class="reference internal" href="999-bibliography.html#id69" title="Tierney, L., Becker, G., and Kalibera, T. (2018).  ALTREP: Alternative Representations for R Objects. URL: https://svn.r-project.org/R/branches/ALTREP/ALTREP.html.">55</a>]</span>
representation of objects, ways to deal with environments
or pairlists, etc.</p>
</aside>
<aside class="footnote brackets" id="footstride" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">4</a><span class="fn-bracket">]</span></span>
<p>(*) A slightly more sophisticated representation
(used, e.g., in GNU GSL and <strong class="program">numpy</strong>) deals with
a <em>sliced</em> array, where we additionally store
the so-called <em>stride</em>. Instead of inspecting elements
one after another, we advance the iterator by a given step size.
This way, we could apply the same function on selected rows
of a matrix (if it is in the column-major order).</p>
</aside>
<aside class="footnote brackets" id="footsexptype" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">5</a><span class="fn-bracket">]</span></span>
<p><code class="file docutils literal notranslate"><span class="pre">src/include/Rinternals.h</span></code> in
R’s source code repository;
see, e.g., <a class="reference external" href="https://svn.r-project.org/R/trunk">https://svn.r-project.org/R/trunk</a>.</p>
</aside>
<aside class="footnote brackets" id="footmod" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">6</a><span class="fn-bracket">]</span></span>
<p>(*) Unless we know what we are doing, e.g., we are certain
that we deal with a local variable in an R function
that invokes our <strong class="command">.Call</strong>.</p>
</aside>
<aside class="footnote brackets" id="footnanrepr" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">7</a><span class="fn-bracket">]</span></span>
<p>(**) Namely, <code class="docutils literal notranslate"><span class="pre">NA</span></code>s are encoded as un-signalling <code class="docutils literal notranslate"><span class="pre">NaN</span></code>s
<code class="docutils literal notranslate"><span class="pre">0x7ff00000000007A2</span></code> of the type <code class="docutils literal notranslate"><span class="pre">double</span></code>
(the lower 32 payload bits are equal to 1954, decimally);
see <code class="file docutils literal notranslate"><span class="pre">src/arithmetic.c</span></code> in R’s source code.
The payload propagation is not fully covered by the current
IEEE 754 floating point standard; see <span id="id30">[<a class="reference internal" href="999-bibliography.html#id75" title="Fog, A. (2018).  NaN Payload Propagation – Unresolved Issues. URL: https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/nan-propagation.pdf.">22</a>]</span>
for discussion. Reliance on such behaviour will thus make
our code platform-dependent. R itself sometimes does that;
theoretically, this may cause <code class="docutils literal notranslate"><span class="pre">NA</span></code>s to be converted
to (other) <code class="docutils literal notranslate"><span class="pre">NaN</span></code>s.</p>
</aside>
<aside class="footnote brackets" id="footgc" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">8</a><span class="fn-bracket">]</span></span>
<p>A <em>safe</em> strategy is to assume that any call to a function
from R’s API may trigger the memory cleanup.
On a side note, we may call the <strong class="command">gc</strong> function
in R to enforce rubbish removal. It also reports
the current memory usage.</p>
</aside>
<aside class="footnote brackets" id="footpreserve" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">9</a><span class="fn-bracket">]</span></span>
<p>(**) <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">R_PreserveObject</strong>
protects an arbitrary <code class="docutils literal notranslate"><span class="pre">SEXP</span></code>
until <strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">R_ReleaseObject</strong> is called
manually. With this mechanism, objects are not automatically
released at the end of a <strong class="command">.Call</strong>.</p>
</aside>
<aside class="footnote brackets" id="footrc" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">10</a><span class="fn-bracket">]</span></span>
<p>To get the object reference counting right,
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">SET_VECTOR_ELT</strong>
needs to unprotect the old element and start protecting
the new one.</p>
</aside>
<aside class="footnote brackets" id="footrprintf" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">11</a><span class="fn-bracket">]</span></span>
<p>Take care when calling
<strong class="program">C</strong><code class="code docutils literal notranslate"><span class="pre">::</span></code><strong class="command">Rprintf</strong>, though.
It should only be used to output messages in the <em>native</em> encoding,
which does not necessarily have to be UTF-8,
although this landscape is slowly changing.
Sticking to ASCII is a safe choice.</p>
</aside>
<aside class="footnote brackets" id="footopenmp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">12</a><span class="fn-bracket">]</span></span>
<p>Most R functions are single-threaded by design.
It is up to the user to decide whether and how they
would like their code to be parallelised. More often than not,
computations in the data science domain are naïvely parallelisable
(e.g., Monte Carlo simulations, exhaustive grid search, etc.).
In such cases, the R package <strong class="program">parallel</strong> might be helpful:
it defines parallel versions of <strong class="command">lapply</strong> and <strong class="command">apply</strong>.
However, for serious jobs, running <em>multiple</em> single-threaded R instances
via, e.g., the <strong class="program">slurm</strong> workload manager might be a better idea
than starting a process that spawns many child threads.</p>
</aside>
</aside>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="320-language.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title"><span class="section-number">15. </span>Unevaluated expressions (*)</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="250-graphics.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title"><span class="section-number">13. </span>Graphics</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              
              
              Copyright &#169; 2022–2024 by <a href="https://www.gagolewski.com/">Marek Gagolewski</a>.
              Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0'>CC BY-NC-ND 4.0</a>.
              Built with <a href="https://sphinx-doc.org/">Sphinx</a>
              and a customised <a href="https://github.com/pradyunsg/furo">Furo</a> theme.
              Last updated on 2024-08-26T12:21:30+0200.
              This site will never display any ads: it is a non-profit project.
              It does not collect any data.
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            In this chapter
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">14. Interfacing compiled code (**)</a><ul>
<li><a class="reference internal" href="#c-and-c-code-in-r">14.1. C and C++ code in R</a><ul>
<li><a class="reference internal" href="#source-files-for-compiled-code-in-r-packages">14.1.1. Source files for compiled code in R packages</a></li>
<li><a class="reference internal" href="#r-cmd-shlib">14.1.2. <code class="code docutils literal notranslate"><span class="pre">R</span> <span class="pre">CMD</span> <span class="pre">SHLIB</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#handling-basic-types">14.2. Handling basic types</a><ul>
<li><a class="reference internal" href="#sexptypes">14.2.1. <code class="docutils literal notranslate"><span class="pre">SEXPTYPE</span></code>s</a></li>
<li><a class="reference internal" href="#accessing-elements-in-simple-atomic-vectors">14.2.2. Accessing elements in simple atomic vectors</a></li>
<li><a class="reference internal" href="#representation-of-missing-values">14.2.3. Representation of missing values</a></li>
<li><a class="reference internal" href="#memory-allocation">14.2.4. Memory allocation</a></li>
<li><a class="reference internal" href="#lists">14.2.5. Lists</a></li>
<li><a class="reference internal" href="#character-vectors-and-individual-strings">14.2.6. Character vectors and individual strings (*)</a></li>
<li><a class="reference internal" href="#calling-r-functions-from-c">14.2.7. Calling R functions from C (**)</a></li>
<li><a class="reference internal" href="#external-pointers">14.2.8. External pointers (**)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dealing-with-compound-types">14.3. Dealing with compound types</a><ul>
<li><a class="reference internal" href="#reading-and-setting-attributes">14.3.1. Reading and setting attributes</a></li>
<li><a class="reference internal" href="#factors">14.3.2. Factors</a></li>
<li><a class="reference internal" href="#matrices">14.3.3. Matrices</a></li>
<li><a class="reference internal" href="#data-frames">14.3.4. Data frames</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-existing-function-libraries">14.4. Using existing function libraries</a><ul>
<li><a class="reference internal" href="#checking-for-user-interrupts">14.4.1. Checking for user interrupts</a></li>
<li><a class="reference internal" href="#generating-pseudorandom-numbers">14.4.2. Generating pseudorandom numbers</a></li>
<li><a class="reference internal" href="#mathematical-functions-from-the-r-api">14.4.3. Mathematical functions from the R API</a></li>
<li><a class="reference internal" href="#header-files-from-other-r-packages">14.4.4. Header files from other R packages (*)</a></li>
<li><a class="reference internal" href="#specifying-compiler-and-linker-flags">14.4.5. Specifying compiler and linker flags (**)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">14.5. Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=d29a5c0e"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/katex.min.js?v=be8ff15f"></script>
    <script src="../_static/auto-render.min.js?v=ad136472"></script>
    <script src="../_static/katex_autorenderer.js?v=bebc588a"></script>
    </body>
</html>