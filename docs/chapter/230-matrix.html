<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="Deep R Programming" name="citation_title" />
<meta content="Marek Gagolewski" name="citation_author" />
<meta content="2024" name="citation_date" />
<meta content="2024" name="citation_publication_date" />
<meta content="https://deepr.gagolewski.com/deepr.pdf" name="citation_pdf_url" />
<meta content="https://deepr.gagolewski.com" name="citation_public_url" />
<meta content="10.5281/zenodo.7490464" name="citation_doi" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="citation_abstract" />
<meta content="summary" name="twitter:card" />
<meta content="Deep R Programming" name="twitter:title" />
<meta content="Deep R Programming" name="og:title" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="twitter:description" />
<meta content="Deep R Programming is a comprehensive and in-depth introductory course on one of the most popular languages for data science. It equips ambitious students, professionals, and researchers with the knowledge and skills to become independent users of this potent environment so that they can tackle any problem related to data wrangling and analytics, numerical computing, statistics, and machine learning. This textbook is a non-profit project. Its online and PDF versions are freely available at https://deepr.gagolewski.com/." name="og:description" />
<meta content="gagolews/deepr" name="og:site_name" />
<meta content="https://deepr.gagolewski.com" name="og:url" />
<meta content="https://deepr.gagolewski.com/_images/cover.png" name="twitter:image" />
<meta content="https://deepr.gagolewski.com/_images/cover.png" name="og:image" />
<meta content="https://deepr.gagolewski.com" name="DC.identifier" />
<meta content="Marek Gagolewski" name="DC.publisher" />
<meta content="INDEX,FOLLOW" name="robots" />
<meta content="book" name="og:type" />
<meta content="9780645571929" name="og:book:isbn" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="12. Data frames" href="240-data-frame.html" /><link rel="prev" title="10. S3 classes" href="220-s3.html" />
        <link rel="canonical" href="https://deepr.gagolewski.com/chapter/230-matrix.html" />

    <link rel="shortcut icon" href="https://www.gagolewski.com/_static/img/deepr.png"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.05.06 -->
        <title>11. Matrices and other arrays - Deep R Programming</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=387cc868" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=1e0fcfc0" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --admonition-font-size: 95%;
  --admonition-title-font-size: 95%;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" /
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Deep R Programming</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
<div class="sidebar-logo-container">
  <a class="sidebar-brand" href="../index.html"><img class="sidebar-logo" src="https://www.gagolewski.com/_static/img/deepr.png" alt="Logo"/></a>
</div>

<span class="sidebar-brand-text">
<a class="sidebar-brand" href="../index.html">Deep R Programming</a>
</span>
<div class="sidebar-brand">
An open-access textbook<br />
by <a href='https://www.gagolewski.com/' style="display: contents">Marek Gagolewski</a><br />
v1.0.1
</div>
<form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author</a></li>
<li class="toctree-l1"><a class="reference external" href="https://deepr.gagolewski.com/deepr.pdf">This book in PDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../order-paper-copy.html">Order a paper copy</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/deepr">Report bugs or typos (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/teaching-data">Datasets</a></li>
<li class="toctree-l1"><a class="reference external" href="https://datawranglingpy.gagolewski.com/">Data wrangling with Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Start here</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="000-preface.html">Preface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deep</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="110-basics.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="120-numeric.html">2. Numeric vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="130-logical.html">3. Logical vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="140-list.html">4. Lists and attributes</a></li>
<li class="toctree-l1"><a class="reference internal" href="150-indexing.html">5. Vector indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="160-character.html">6. Character vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="170-function.html">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="180-flow.html">8. Flow of execution</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deeper</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="210-design.html">9. Designing functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="220-s3.html">10. S3 classes</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">11. Matrices and other arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="240-data-frame.html">12. Data frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="250-graphics.html">13. Graphics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deepest</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="310-compiled.html">14. Interfacing compiled code (**)</a></li>
<li class="toctree-l1"><a class="reference internal" href="320-language.html">15. Unevaluated expressions (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="330-environment.html">16. Environments and evaluation (*)</a></li>
<li class="toctree-l1"><a class="reference internal" href="340-lazy.html">17. Lazy evaluation (**)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="998-changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="999-bibliography.html">References</a></li>
</ul>

</div></div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="edit-this-page">
  <a class="muted-link" href="https://github.com/gagolews/deepr" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto colour theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="matrices-and-other-arrays">
<span id="chap-matrix"></span><h1><span class="section-number">11. </span>Matrices and other arrays<a class="headerlink" href="#matrices-and-other-arrays" title="Link to this heading">¶</a></h1>
<blockquote>
<div><p><em>This open-access textbook
is, and will remain, freely available for everyone’s enjoyment
(also in <a class="reference external" href="https://deepr.gagolewski.com/deepr.pdf">PDF</a>;
a paper copy can also be <a class="reference internal" href="../order-paper-copy.html"><span class="doc std std-doc">ordered</span></a>).
It is a non-profit project. Although available online, it is a whole course,
and should be read from the beginning to the end.
Refer to the <a class="reference internal" href="000-preface.html#chap-preface"><span class="std std-ref">Preface</span></a> for general introductory remarks. Any
<a class="reference external" href="https://github.com/gagolews/deepr">bug/typo reports/fixes</a>
are appreciated. Make sure to check out
<a class="reference external" href="https://datawranglingpy.gagolewski.com/"><em>Minimalist Data Wrangling with Python</em></a>
<span id="id1">[<a class="reference internal" href="999-bibliography.html#id3" title="Gagolewski, M. (2024).  Minimalist Data Wrangling with Python. URL: https://datawranglingpy.gagolewski.com/, DOI: 10.5281/zenodo.6451068.">27</a>]</span>, too.</em></p>
</div></blockquote>
<p>When we equip an atomic or generic vector with the <code class="docutils literal notranslate"><span class="pre">dim</span></code> attribute,
it automatically becomes an object of the S3 class <code class="docutils literal notranslate"><span class="pre">array</span></code>.
In particular, two-dimensional arrays (of the primary S3 class <code class="docutils literal notranslate"><span class="pre">matrix</span></code>)
allow us to represent <em>tabular</em> data where items are aligned into rows
and columns:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">structure</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">))</span><span class="w">  </span><span class="c1"># a matrix with two rows and three columns</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    3    5</span>
<span class="c1">## [2,]    2    4    6</span>
</pre></div>
</div>
<p>Combined with the fact that there are many functions overloaded
for the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> class, we have just opened up a whole world of new
possibilities, which we explore in this chapter.
Namely, we will discuss how to perform the algebraic operations
such as matrix multiplication, transpose, finding eigenvalues,
and performing various decompositions. We will also cover data wrangling
operations such as array subsetting and column- and rowwise aggregation.
Furthermore, the next chapter will present data frames:
matrix-like objects whose columns can be of any (not necessarily
the same) type.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Oftentimes, a numeric matrix with <span class="math">\(n\)</span> rows and <span class="math">\(m\)</span> columns
is used to represent <span class="math">\(n\)</span> points (samples, observations)
in an <span class="math">\(m\)</span>-dimensional space (with <span class="math">\(m\)</span> numeric features or variables),
<span class="math">\(\mathbb{R}^m\)</span>.</p>
</div>
<section id="creating-arrays">
<h2><span class="section-number">11.1. </span>Creating arrays<a class="headerlink" href="#creating-arrays" title="Link to this heading">¶</a></h2>
<section id="matrix-and-array">
<h3><span class="section-number">11.1.1. </span><strong class="command">matrix</strong> and <strong class="command">array</strong><a class="headerlink" href="#matrix-and-array" title="Link to this heading">¶</a></h3>
<p>A matrix can be conveniently created using the following function.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
<span class="c1">## [2,]    4    5    6</span>
</pre></div>
</div>
<p>It converted an atomic vector of length six to a matrix with two rows.
The number of columns was determined automatically (<code class="docutils literal notranslate"><span class="pre">ncol=3</span></code> could have
been passed, additionally or instead, to get the same result).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>By default, the elements of the input vector are read column by column:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="p">)</span><span class="w">  </span><span class="c1"># byrow=FALSE</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    3    5</span>
<span class="c1">## [2,]    2    4    6</span>
</pre></div>
</div>
</div>
<p>A matrix can be equipped with an attribute that defines dimension names,
being a list of two character vectors of appropriate sizes which label
each row and column:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">dimnames</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">)))</span>
<span class="c1">##   a b c</span>
<span class="c1">## x 1 2 3</span>
<span class="c1">## y 4 5 6</span>
</pre></div>
</div>
<p>Alternatively, to create a matrix, we can use the <strong class="command">array</strong> function.
It requires the number of rows and columns to be specified explicitly.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">array</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    3    5</span>
<span class="c1">## [2,]    2    4    6</span>
</pre></div>
</div>
<p>The elements were consumed in the column-major order.</p>
<p>Arrays of other dimensionalities are also possible.
Here is a one-dimensional array:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">array</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="m">6</span><span class="p">)</span>
<span class="c1">## [1] 1 2 3 4 5 6</span>
</pre></div>
</div>
<p>When printed, it is indistinguishable
from an atomic vector (but the <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute is still
set to <code class="docutils literal notranslate"><span class="pre">array</span></code>).</p>
<p>And now for something completely different: a three-dimensional array
of size <span class="math">\(3\times 4\times 2\)</span>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">array</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">24</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span>
<span class="c1">## , , 1</span>
<span class="c1">##</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    4    7   10</span>
<span class="c1">## [2,]    2    5    8   11</span>
<span class="c1">## [3,]    3    6    9   12</span>
<span class="c1">##</span>
<span class="c1">## , , 2</span>
<span class="c1">##</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]   13   16   19   22</span>
<span class="c1">## [2,]   14   17   20   23</span>
<span class="c1">## [3,]   15   18   21   24</span>
</pre></div>
</div>
<p>It can be thought of as two matrices of size <span class="math">\(3\times 4\)</span>
(because how else can we print out a 3D object on a 2D console?).</p>
<p>The <strong class="command">array</strong> function can be fed with the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> argument, too.
For instance, the above three-dimensional hypertable
would require a list of three character vectors
of sizes 3, 4, and 2, respectively.</p>
<div class="proof proof-type-exercise" id="id14">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.1</span>
        
    </div><div class="proof-content">
<p>Verify that 5-dimensional arrays can also be created.</p>
</div></div></section>
<section id="promoting-and-stacking-vectors">
<span id="sec-cbind-matrix"></span><h3><span class="section-number">11.1.2. </span>Promoting and stacking vectors<a class="headerlink" href="#promoting-and-stacking-vectors" title="Link to this heading">¶</a></h3>
<p>We can promote an ordinary vector to a <em>column vector</em>, i.e.,
a matrix with one column, by calling:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">as.matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">)</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    1</span>
<span class="c1">## [2,]    2</span>
<span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">)</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    1</span>
<span class="c1">## [2,]    2</span>
</pre></div>
</div>
<p>and to a row vector:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">t</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">)</span><span class="w">  </span><span class="c1"># transpose</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
<span class="nf">rbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">)</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
</pre></div>
</div>
<p>Actually, <strong class="command">cbind</strong> and <strong class="command">rbind</strong> stand for column- and
row-bind. They permit multiple vectors and matrices to be stacked
one after/below another:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">rbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="o">:</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="p">)</span><span class="w">  </span><span class="c1"># row-bind</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="c1">## [2,]    5    6    7    8</span>
<span class="c1">## [3,]    9   10    9   10</span>
<span class="c1">## [4,]   11   11   11   11</span>
<span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="o">:</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="p">)</span><span class="w">  </span><span class="c1"># column-bind</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    5    9   11</span>
<span class="c1">## [2,]    2    6   10   11</span>
<span class="c1">## [3,]    3    7    9   11</span>
<span class="c1">## [4,]    4    8   10   11</span>
<span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="o">:</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="m">11</span><span class="o">:</span><span class="m">13</span><span class="p">,</span><span class="w"> </span><span class="m">21</span><span class="o">:</span><span class="m">23</span><span class="p">))</span><span class="w">  </span><span class="c1"># vector, vector, 2x3 matrix</span>
<span class="c1">##      [,1] [,2] [,3] [,4] [,5]</span>
<span class="c1">## [1,]    1    3   11   12   13</span>
<span class="c1">## [2,]    2    4   21   22   23</span>
</pre></div>
</div>
<p>and so forth.
Unfortunately, the <em>generalised</em> recycling rule is not implemented in full:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="nf">cbind</span><span class="p">(</span><span class="m">9</span><span class="o">:</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="p">))</span><span class="w">  </span><span class="c1"># different from cbind(1:4, 5:8, 9:10, 11)</span>
<span class="c1">## Warning in cbind(1:4, 5:8, cbind(9:10, 11)): number of rows of result is</span>
<span class="c1">##     not a multiple of vector length (arg 1)</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    5    9   11</span>
<span class="c1">## [2,]    2    6   10   11</span>
</pre></div>
</div>
<p>Note that the first two arguments were of length four.</p>
</section>
<section id="simplifying-lists">
<span id="sec-simplify2array"></span><h3><span class="section-number">11.1.3. </span>Simplifying lists<a class="headerlink" href="#simplifying-lists" title="Link to this heading">¶</a></h3>
<p><strong class="command">simplify2array</strong> is an extension of the <strong class="command">unlist</strong> function.
Given a list of atomic vectors, each of length one, it will return a flat
atomic vector. However, if longer vectors of the same lengths are given,
they will be converted to a matrix.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">simplify2array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="m">21</span><span class="p">))</span><span class="w">  </span><span class="c1"># each of length one</span>
<span class="c1">## [1]  1 11 21</span>
<span class="nf">simplify2array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">13</span><span class="p">,</span><span class="w"> </span><span class="m">21</span><span class="o">:</span><span class="m">23</span><span class="p">,</span><span class="w"> </span><span class="m">31</span><span class="o">:</span><span class="m">33</span><span class="p">))</span><span class="w">  </span><span class="c1"># each of length three</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1   11   21   31</span>
<span class="c1">## [2,]    2   12   22   32</span>
<span class="c1">## [3,]    3   13   23   33</span>
<span class="nf">simplify2array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="m">21</span><span class="o">:</span><span class="m">23</span><span class="p">))</span><span class="w">  </span><span class="c1"># no can do (without warning!)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] 1</span>
<span class="c1">##</span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] 11 12</span>
<span class="c1">##</span>
<span class="c1">## [[3]]</span>
<span class="c1">## [1] 21 22 23</span>
</pre></div>
</div>
<p>In the second example, each vector becomes
a separate column of the resulting matrix,
which can easily be justified by the fact that
matrix elements are stored in a columnwise order.</p>
<div class="proof proof-type-example" id="id15">

    <div class="proof-title">
        <span class="proof-type">Example 11.2</span>
        
    </div><div class="proof-content">
<p>Quite a few functions call the foregoing automatically;
compare the <code class="docutils literal notranslate"><span class="pre">simplify</span></code> argument to <strong class="command">apply</strong>,
<strong class="command">sapply</strong>, <strong class="command">tapply</strong>, or <strong class="command">replicate</strong>,
and the <code class="docutils literal notranslate"><span class="pre">SIMPLIFY</span></code> (sic!) argument to <strong class="command">mapply</strong>. For instance,
<strong class="command">sapply</strong> combines <strong class="command">lapply</strong>
with <strong class="command">simplify2array</strong>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">min_mean_max</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Min</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">Mean</span><span class="o">=</span><span class="nf">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">Max</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nf">sapply</span><span class="p">(</span><span class="nf">split</span><span class="p">(</span><span class="n">iris</span><span class="p">[[</span><span class="s">&quot;Sepal.Length&quot;</span><span class="p">]],</span><span class="w"> </span><span class="n">iris</span><span class="p">[[</span><span class="s">&quot;Species&quot;</span><span class="p">]]),</span><span class="w"> </span><span class="n">min_mean_max</span><span class="p">)</span>
<span class="c1">##      setosa versicolor virginica</span>
<span class="c1">## Min   4.300      4.900     4.900</span>
<span class="c1">## Mean  5.006      5.936     6.588</span>
<span class="c1">## Max   5.800      7.000     7.900</span>
</pre></div>
</div>
<p>Take note of what constitutes the columns of the return matrix.</p>
</div></div><div class="proof proof-type-exercise" id="id16">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.3</span>
        
    </div><div class="proof-content">
<p>Inspect the behaviour of <strong class="command">as.matrix</strong> on list arguments.
Write your version of <strong class="command">simplify2array</strong>
named <strong class="command">as.matrix.list</strong> that <em>always</em>
returns a matrix. If a list of non-equisized vectors is given,
fill the missing cells with <code class="docutils literal notranslate"><span class="pre">NA</span></code>s and generate a warning.</p>
</div></div><div class="admonition important">
<p class="admonition-title">Important</p>
<p>Sometimes a call to <strong class="command">do.call</strong><code class="code docutils literal notranslate"><span class="pre">(</span></code><strong class="command">cbind</strong><code class="code docutils literal notranslate"><span class="pre">,</span> <span class="pre">x)</span></code>
might be a better idea than a referral to <strong class="command">simplify2array</strong>.
Provided that <code class="docutils literal notranslate"><span class="pre">x</span></code> is a list of atomic vectors,
it <em>always</em> returns a matrix: shorter vectors are recycled
(which might be welcome, but not necessarily).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">do.call</span><span class="p">(</span><span class="n">cbind</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="o">=</span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="m">6</span><span class="p">)))</span>
<span class="c1">## Warning in (function (..., deparse.level = 1) : number of rows of result</span>
<span class="c1">##     is not a multiple of vector length (arg 2)</span>
<span class="c1">##   a b c</span>
<span class="c1">## i 1 2 4</span>
<span class="c1">## j 1 3 5</span>
<span class="c1">## k 1 2 6</span>
</pre></div>
</div>
</div>
<div class="proof proof-type-example" id="id17">

    <div class="proof-title">
        <span class="proof-type">Example 11.4</span>
        
    </div><div class="proof-content">
<p>Consider a toy named list of numeric vectors:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="nf">runif</span><span class="p">(</span><span class="m">10</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="nf">rnorm</span><span class="p">(</span><span class="m">15</span><span class="p">))</span>
</pre></div>
</div>
<p>Compare the results generated by <strong class="command">sapply</strong>
(which calls <strong class="command">simplify2array</strong>):</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Mean</span><span class="o">=</span><span class="nf">mean</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
<span class="c1">##  a.Mean  b.Mean</span>
<span class="c1">## 0.57825 0.12431</span>
<span class="nf">sapply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Min</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"> </span><span class="n">Max</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
<span class="c1">##            a       b</span>
<span class="c1">## Min 0.045556 -1.9666</span>
<span class="c1">## Max 0.940467  1.7869</span>
</pre></div>
</div>
<p>with its version based on <strong class="command">do.call</strong> and <strong class="command">cbind</strong>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">sapply2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="kc">...</span><span class="p">)</span>
<span class="w">    </span><span class="nf">do.call</span><span class="p">(</span><span class="n">cbind</span><span class="p">,</span><span class="w"> </span><span class="nf">lapply</span><span class="p">(</span><span class="kc">...</span><span class="p">))</span>

<span class="nf">sapply2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Mean</span><span class="o">=</span><span class="nf">mean</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
<span class="c1">##            a       b</span>
<span class="c1">## Mean 0.57825 0.12431</span>
<span class="nf">sapply2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Min</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"> </span><span class="n">Max</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
<span class="c1">##            a       b</span>
<span class="c1">## Min 0.045556 -1.9666</span>
<span class="c1">## Max 0.940467  1.7869</span>
</pre></div>
</div>
<p>Notice that <strong class="command">sapply</strong> may return an atomic vector
with somewhat surprising <code class="docutils literal notranslate"><span class="pre">names</span></code>.</p>
</div></div><p>See <a class="reference internal" href="240-data-frame.html#sec-df-group-by"><span class="std std-numref">Section 12.3.7</span></a> for a few more examples.</p>
</section>
<section id="beyond-numeric-arrays">
<h3><span class="section-number">11.1.4. </span>Beyond numeric arrays<a class="headerlink" href="#beyond-numeric-arrays" title="Link to this heading">¶</a></h3>
<p>Arrays based on non-numeric vectors are also possible.
For instance, we will later stress that matrix comparisons
are performed elementwisely. They spawn logical matrices:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span>
<span class="c1">##       [,1]  [,2] [,3]</span>
<span class="c1">## [1,] FALSE FALSE TRUE</span>
<span class="c1">## [2,]  TRUE  TRUE TRUE</span>
</pre></div>
</div>
<p>Matrices of character strings can be useful too:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">matrix</span><span class="p">(</span><span class="nf">strrep</span><span class="p">(</span><span class="kc">LETTERS</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">],</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="p">)</span>
<span class="c1">##      [,1] [,2]   [,3]</span>
<span class="c1">## [1,] &quot;A&quot;  &quot;CCC&quot;  &quot;EEEEE&quot;</span>
<span class="c1">## [2,] &quot;BB&quot; &quot;DDDD&quot; &quot;FFFFFF&quot;</span>
</pre></div>
</div>
<p>And, of course, complex matrices:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1i</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,] 1+1i 2+1i 3+1i</span>
<span class="c1">## [2,] 4+1i 5+1i 6+1i</span>
</pre></div>
</div>
<p>We are not limited to <em>atomic</em> vectors. Lists can
be a basis for arrays as well:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">matrix</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">21</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)),</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="c1">##      [,1]       [,2]</span>
<span class="c1">## [1,] 1          &quot;A&quot;</span>
<span class="c1">## [2,] integer,11 list,3</span>
</pre></div>
</div>
<p>Certain elements are not <em>displayed</em> correctly, but they <em>are</em> still there.</p>
</section>
<section id="internal-representation">
<span id="sec-matrix-representation"></span><h3><span class="section-number">11.1.5. </span>Internal representation<a class="headerlink" href="#internal-representation" title="Link to this heading">¶</a></h3>
<p>An object of the S3 class <code class="docutils literal notranslate"><span class="pre">array</span></code> is an atomic vector or a list
equipped with the <code class="docutils literal notranslate"><span class="pre">dims</span></code> attribute being a vector of nonnegative integers.
Interestingly, we do not have to set the <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute explicitly:
the accessor function <strong class="command">class</strong> will return an implicit<a class="footnote-reference brackets" href="#footunclass" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
class anyway.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">class</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w">  </span><span class="c1"># atomic vector</span>
<span class="c1">## [1] &quot;numeric&quot;</span>
<span class="nf">class</span><span class="p">(</span><span class="nf">structure</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)))</span><span class="w">  </span><span class="c1"># 1D array (vector)</span>
<span class="c1">## [1] &quot;array&quot;</span>
<span class="nf">class</span><span class="p">(</span><span class="nf">structure</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">)))</span><span class="w">  </span><span class="c1"># 2D array (matrix)</span>
<span class="c1">## [1] &quot;matrix&quot; &quot;array&quot;</span>
<span class="nf">class</span><span class="p">(</span><span class="nf">structure</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">rep</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)))</span><span class="w">  </span><span class="c1"># 3D array</span>
<span class="c1">## [1] &quot;array&quot;</span>
</pre></div>
</div>
<p>Note that a two-dimensional array is additionally of the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> class.</p>
<p>Optional dimension names are represented by means of the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code>
attribute, which is a list of <span class="math">\(d\)</span> character vectors,
where <span class="math">\(d\)</span> is the array’s dimensionality.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">structure</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">dim</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="n">dimnames</span><span class="o">=</span><span class="nf">list</span><span class="p">(</span><span class="kc">letters</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="kc">LETTERS</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">])))</span>
<span class="c1">##   A B C</span>
<span class="c1">## a 1 3 5</span>
<span class="c1">## b 2 4 6</span>
<span class="nf">dim</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w">  </span><span class="c1"># or attr(A, &quot;dim&quot;)</span>
<span class="c1">## [1] 2 3</span>
<span class="nf">dimnames</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w">  </span><span class="c1"># or attr(A, &quot;dimnames&quot;)</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] &quot;a&quot; &quot;b&quot;</span>
<span class="c1">##</span>
<span class="c1">## [[2]]</span>
<span class="c1">## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Internally, elements in an array are
stored in the column-major (Fortran) order:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">as.numeric</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w">  </span><span class="c1"># drop all attributes to reveal the underlying numeric vector</span>
<span class="c1">## [1] 1 2 3 4 5 6</span>
</pre></div>
</div>
<p>Setting <code class="docutils literal notranslate"><span class="pre">byrow=TRUE</span></code> in a call to the <strong class="command">matrix</strong> function
only affects the order in which this constructor <em>reads</em> a given source
vector, not the resulting column/row-majorness.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
<span class="c1">## [2,]    4    5    6</span>
<span class="nf">as.numeric</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="c1">## [1] 1 4 2 5 3 6</span>
</pre></div>
</div>
</div>
<p>The two said special attributes can be modified through the replacement
functions `<strong class="command">dim&lt;-</strong>` and `<strong class="command">dimnames&lt;-</strong>`
(and, of course, `<strong class="command">attr&lt;-</strong>` as well).
In particular, changing <code class="docutils literal notranslate"><span class="pre">dim</span></code> does not alter the underlying atomic vector.
It only affects how other functions, including the corresponding
<strong class="command">print</strong> method, interpret their placement on a virtual grid:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">`dim&lt;-`</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">  </span><span class="c1"># not the same as the transpose of `A`</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    1    4</span>
<span class="c1">## [2,]    2    5</span>
<span class="c1">## [3,]    3    6</span>
</pre></div>
</div>
<p>We obtained a different <em>view</em> of the same <em>flat</em> data vector.
Also, the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> attribute was dropped because its size became
incompatible with the newly requested dimensionality.</p>
<div class="proof proof-type-exercise" id="id18">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.5</span>
        
    </div><div class="proof-content">
<p>Study the source code of the <strong class="command">nrow</strong>,
<strong class="command">NROW</strong>, <strong class="command">ncol</strong>, <strong class="command">NCOL</strong>,
<strong class="command">rownames</strong>, <strong class="command">row.names</strong>, and
<strong class="command">colnames</strong> functions.</p>
</div></div><p>Interestingly, for one-dimensional arrays, the
<strong class="command">names</strong> function returns a reasonable value
(based on the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> attribute, which is a list with one character
vector), despite the <code class="docutils literal notranslate"><span class="pre">names</span></code> attribute’s not being set.</p>
<p>What is more, the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> attribute itself can be named:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">names</span><span class="p">(</span><span class="nf">dimnames</span><span class="p">(</span><span class="n">A</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;ROWS&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;COLUMNS&quot;</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">##     COLUMNS</span>
<span class="c1">## ROWS A B C</span>
<span class="c1">##    a 1 3 5</span>
<span class="c1">##    b 2 4 6</span>
</pre></div>
</div>
<p>It is still a numeric matrix, but its presentation has been
slightly prettified.</p>
<div class="proof proof-type-exercise" id="id19">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.6</span>
        
    </div><div class="proof-content">
<p><strong class="command">outer</strong> applies an elementwisely vectorised function
on each pair of elements from two vectors, forming a two-dimensional
result grid. Implement it yourself based on two calls to <strong class="command">rep</strong>.
Some examples:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">outer</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">=</span><span class="m">100</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">=</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="m">4</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># multiplication</span>
<span class="c1">##     a   b   c   d</span>
<span class="c1">## x   1   2   3   4</span>
<span class="c1">## y  10  20  30  40</span>
<span class="c1">## z 100 200 300 400</span>
<span class="nf">outer</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">),</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="n">paste</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s">&quot;-&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># concatenate strings</span>
<span class="c1">##      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]</span>
<span class="c1">## [1,] &quot;A-1&quot; &quot;A-2&quot; &quot;A-3&quot; &quot;A-4&quot; &quot;A-5&quot; &quot;A-6&quot; &quot;A-7&quot; &quot;A-8&quot;</span>
<span class="c1">## [2,] &quot;B-1&quot; &quot;B-2&quot; &quot;B-3&quot; &quot;B-4&quot; &quot;B-5&quot; &quot;B-6&quot; &quot;B-7&quot; &quot;B-8&quot;</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id20">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.7</span>
        
    </div><div class="proof-content">
<p>Show how <strong class="command">match</strong><code class="code docutils literal notranslate"><span class="pre">(y,</span> <span class="pre">z)</span></code> can be implemented
using <strong class="command">outer</strong>. Is its time and memory complexity
optimal, though?</p>
</div></div><div class="proof proof-type-exercise" id="id21">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.8</span>
        
    </div><div class="proof-content">
<p><strong class="command">table</strong> creates a contingency matrix/array that counts the number
of unique elements or unique pairs of corresponding items from one or more
vectors of equal lengths. Write its one- and two-argument version based on
<strong class="command">tabulate</strong>. For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">tips</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">read.csv</span><span class="p">(</span><span class="nf">paste0</span><span class="p">(</span><span class="s">&quot;https://github.com/gagolews/teaching-data/raw/&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;master/other/tips.csv&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">comment.char</span><span class="o">=</span><span class="s">&quot;#&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># a data.frame (list)</span>
<span class="nf">table</span><span class="p">(</span><span class="n">tips</span><span class="p">[[</span><span class="s">&quot;day&quot;</span><span class="p">]])</span>
<span class="c1">##</span>
<span class="c1">##  Fri  Sat  Sun Thur</span>
<span class="c1">##   19   87   76   62</span>
<span class="nf">table</span><span class="p">(</span><span class="n">tips</span><span class="p">[[</span><span class="s">&quot;smoker&quot;</span><span class="p">]],</span><span class="w"> </span><span class="n">tips</span><span class="p">[[</span><span class="s">&quot;day&quot;</span><span class="p">]])</span>
<span class="c1">##</span>
<span class="c1">##       Fri Sat Sun Thur</span>
<span class="c1">##   No    4  45  57   45</span>
<span class="c1">##   Yes  15  42  19   17</span>
</pre></div>
</div>
</div></div></section>
</section>
<section id="array-indexing">
<h2><span class="section-number">11.2. </span>Array indexing<a class="headerlink" href="#array-indexing" title="Link to this heading">¶</a></h2>
<p>Array subsetting can be performed by means of the overloaded<a class="footnote-reference brackets" href="#footsqover" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
`<strong class="command">[</strong>` method.</p>
<section id="arrays-are-built-on-basic-vectors">
<h3><span class="section-number">11.2.1. </span>Arrays are built on basic vectors<a class="headerlink" href="#arrays-are-built-on-basic-vectors" title="Link to this heading">¶</a></h3>
<p>Consider two example matrices:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="c1">## [2,]    5    6    7    8</span>
<span class="c1">## [3,]    9   10   11   12</span>
<span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">`dimnames&lt;-`</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="nf">list</span><span class="p">(</span><span class="w">  </span><span class="c1"># copy of `A` with `dimnames` set</span>
<span class="w">    </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">),</span><span class="w">      </span><span class="c1"># row labels</span>
<span class="w">    </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;z&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;w&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># column labels</span>
<span class="p">)))</span>
<span class="c1">##   x  y  z  w</span>
<span class="c1">## a 1  2  3  4</span>
<span class="c1">## b 5  6  7  8</span>
<span class="c1">## c 9 10 11 12</span>
</pre></div>
</div>
<p>Subsetting based on one indexer (as in <a class="reference internal" href="150-indexing.html#chap-indexing"><span class="std std-numref">Chapter 5</span></a>)
will refer to the underlying flat vector.
For instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="m">6</span><span class="p">]</span>
<span class="c1">## [1] 10</span>
</pre></div>
</div>
<p>It is the element in the third row, second column.
Recall that values are stored in the column-major order.</p>
</section>
<section id="selecting-individual-elements">
<h3><span class="section-number">11.2.2. </span>Selecting individual elements<a class="headerlink" href="#selecting-individual-elements" title="Link to this heading">¶</a></h3>
<p>Our example <span class="math">\(3\times 4\)</span> real matrix
<span class="math">\(\mathbf{A}\in\mathbb{R}^{3\times 4}\)</span> is like:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
\mathbf{A}=
\left[
\begin{array}{cccc}
a_{1, 1} & a_{1, 2} & a_{1, 3} & a_{1, 4}  \\
a_{2, 1} & a_{2, 2} & a_{2, 3} & a_{2, 4}  \\
a_{3, 1} & a_{3, 2} & a_{3, 3} & a_{3, 4}  \\
\end{array}
\right]
=
\left[
\begin{array}{cccc}
1 & 2 & 3 & 4\\
5 & 6 & 7 & 8 \\
9 & 10& 11& 12 \\
\end{array}
\right].
\]</div>
</div>
<p>Matrix elements are aligned in a two-dimensional grid.
Hence, we can pinpoint a cell using two indexes.
In mathematical notation, <span class="math">\(a_{i,j}\)</span> refers to the <span class="math">\(i\)</span>-th row
and the <span class="math">\(j\)</span>-th column. Similarly in R:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">  </span><span class="c1"># the third row, the second column</span>
<span class="c1">## [1] 10</span>
<span class="n">B</span><span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="p">]</span><span class="w">  </span><span class="c1"># using dimnames == B[3, 2]</span>
<span class="c1">## [1] 10</span>
</pre></div>
</div>
</section>
<section id="selecting-rows-and-columns">
<h3><span class="section-number">11.2.3. </span>Selecting rows and columns<a class="headerlink" href="#selecting-rows-and-columns" title="Link to this heading">¶</a></h3>
<p>Some textbooks, and we are fond of this notation here as well,
mark with <span class="math">\(\mathbf{a}_{i,\cdot}\)</span>
a vector that consists of all the elements in
the <span class="math">\(i\)</span>-th row and with <span class="math">\(\mathbf{a}_{\cdot,j}\)</span> all items
in the <span class="math">\(j\)</span>-th column.
In R, this corresponds to one of the indexers being left out.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c1"># the third row</span>
<span class="c1">## [1]  9 10 11 12</span>
<span class="n">A</span><span class="p">[,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">  </span><span class="c1"># the second column</span>
<span class="c1">## [1]  2  6 10</span>
<span class="n">B</span><span class="p">[</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c1"># or B[3, ]</span>
<span class="c1">##  x  y  z  w</span>
<span class="c1">##  9 10 11 12</span>
<span class="n">B</span><span class="p">[,</span><span class="w"> </span><span class="s">&quot;y&quot;</span><span class="p">]</span><span class="w">  </span><span class="c1"># or B[, 2]</span>
<span class="c1">##  a  b  c</span>
<span class="c1">##  2  6 10</span>
</pre></div>
</div>
<p>Let’s stress that <code class="docutils literal notranslate"><span class="pre">A[1]</span></code>, <code class="docutils literal notranslate"><span class="pre">A[1,</span> <span class="pre">]</span></code>, and <code class="docutils literal notranslate"><span class="pre">A[,</span> <span class="pre">1]</span></code> have different
meanings. Also, we see that the results’ <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> are adjusted accordingly;
see also <strong class="command">unname</strong>, which can take care of them once and for all.</p>
<div class="proof proof-type-exercise" id="id22">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.9</span>
        
    </div><div class="proof-content">
<p>Use <strong class="command">duplicated</strong> to remove repeating rows
in a given numeric matrix (see also <strong class="command">unique</strong>).</p>
</div></div></section>
<section id="dropping-dimensions">
<span id="sec-index-matrix-drop"></span><h3><span class="section-number">11.2.4. </span>Dropping dimensions<a class="headerlink" href="#dropping-dimensions" title="Link to this heading">¶</a></h3>
<p>Extracting an individual element or a single row/column from a matrix
brings about an atomic vector. If the resulting object’s <code class="docutils literal notranslate"><span class="pre">dim</span></code> attribute
consists of 1s only, it will be removed whatsoever; see also the
<strong class="command">drop</strong> function which removes the dimensions with only one level.</p>
<p>In order to obtain proper row and column vectors, we can request the
preservation of the dimensionality of the output object
(and, more precisely, the length of <code class="docutils literal notranslate"><span class="pre">dim</span></code>). This can be
done by passing <code class="docutils literal notranslate"><span class="pre">drop=FALSE</span></code> to `<strong class="command">[</strong>`.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span><span class="w">  </span><span class="c1"># the first row, second column</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    2</span>
<span class="n">A</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span><span class="w">  </span><span class="c1"># the first row</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span><span class="w">  </span><span class="c1"># the second column</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    2</span>
<span class="c1">## [2,]    6</span>
<span class="c1">## [3,]   10</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Unfortunately, the <code class="docutils literal notranslate"><span class="pre">drop</span></code> argument defaults to <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>. Many bugs could be
avoided otherwise, primarily when the indexers are generated
programmatically.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For list-based matrices,
we can also use a multi-argument
version of `<strong class="command">[[</strong>` to extract the individual elements.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">11</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="m">21</span><span class="o">:</span><span class="m">23</span><span class="p">,</span><span class="w"> </span><span class="m">31</span><span class="o">:</span><span class="m">34</span><span class="p">),</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="n">C</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w">  </span><span class="c1"># for `[`, input type is the same as the output type, hence a list</span>
<span class="c1">## [[1]]</span>
<span class="c1">## [1] 21 22 23</span>
<span class="n">C</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,] integer,3</span>
<span class="n">C</span><span class="p">[[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">]]</span><span class="w">  </span><span class="c1"># extract</span>
<span class="c1">## [1] 21 22 23</span>
</pre></div>
</div>
</div>
</section>
<section id="selecting-submatrices">
<h3><span class="section-number">11.2.5. </span>Selecting submatrices<a class="headerlink" href="#selecting-submatrices" title="Link to this heading">¶</a></h3>
<p>Indexing based on two vectors, both of length two or more, extracts
a sub-block of a given matrix.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">)]</span><span class="w">  </span><span class="c1"># rows 1 and 2, columns 1, 2, and 4</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    4</span>
<span class="c1">## [2,]    5    6    8</span>
<span class="n">B</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">),</span><span class="w"> </span><span class="m">-3</span><span class="p">]</span><span class="w">  </span><span class="c1"># some rows, omit the third column</span>
<span class="c1">##   x y w</span>
<span class="c1">## a 1 2 4</span>
<span class="c1">## b 5 6 8</span>
</pre></div>
</div>
<p>Note again that we have <code class="docutils literal notranslate"><span class="pre">drop=TRUE</span></code> by default, which affects
the operator’s behaviour if one of the indexers is a scalar.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="p">]</span>
<span class="c1">## [1]  3 11</span>
<span class="n">A</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    3</span>
<span class="c1">## [2,]   11</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id23">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.10</span>
        
    </div><div class="proof-content">
<p>Define the <strong class="command">split</strong> method for the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> class that
returns a list of <span class="math">\(n\)</span> matrices when given a matrix with <span class="math">\(n\)</span> rows and an
object of the class <code class="docutils literal notranslate"><span class="pre">factor</span></code> of length <span class="math">\(n\)</span> (or a list of such objects).
For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">split.matrix</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">...to.do...</span>
<span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">)</span><span class="w">  </span><span class="c1"># matrix whose rows are to be split</span>
<span class="n">s</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">factor</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">))</span><span class="w">  </span><span class="c1"># determines a grouping of rows</span>
<span class="nf">split</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
<span class="c1">## $a</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    4    7   10</span>
<span class="c1">## [2,]    3    6    9   12</span>
<span class="c1">##</span>
<span class="c1">## $b</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    2    5    8   11</span>
</pre></div>
</div>
</div></div></section>
<section id="selecting-elements-based-on-logical-vectors">
<h3><span class="section-number">11.2.6. </span>Selecting elements based on logical vectors<a class="headerlink" href="#selecting-elements-based-on-logical-vectors" title="Link to this heading">¶</a></h3>
<p>Logical vectors can also be used as indexers, with consequences
that are not hard to guess:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="nf">c</span><span class="p">(</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">,</span><span class="w"> </span><span class="kc">TRUE</span><span class="p">),</span><span class="w"> </span><span class="m">-1</span><span class="p">]</span><span class="w">  </span><span class="c1"># select 1st and 3rd row, omit 1st column</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    4    7   10</span>
<span class="c1">## [2,]    6    9   12</span>
<span class="n">B</span><span class="p">[</span><span class="n">B</span><span class="p">[,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">B</span><span class="p">[,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">]</span><span class="o">&lt;=</span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c1"># all rows where x&#39;s contents are in (1, 9]</span>
<span class="c1">##   x  y  z  w</span>
<span class="c1">## b 5  6  7  8</span>
<span class="c1">## c 9 10 11 12</span>
<span class="n">A</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="nf">colMeans</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">drop</span><span class="o">=</span><span class="kc">FALSE</span><span class="p">]</span><span class="w">  </span><span class="c1"># 2nd row and the columns whose means &gt; 6</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    8   11</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#sec-matrix-op"><span class="std std-numref">Section 11.3</span></a> notes that comparisons involving matrices
are performed in an elementwise manner. For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">&gt;</span><span class="m">7</span>
<span class="c1">##       [,1]  [,2]  [,3] [,4]</span>
<span class="c1">## [1,] FALSE FALSE FALSE TRUE</span>
<span class="c1">## [2,] FALSE FALSE  TRUE TRUE</span>
<span class="c1">## [3,] FALSE FALSE  TRUE TRUE</span>
</pre></div>
</div>
<p>Such logical matrices can be used to subset other matrices of the
same size. This kind of indexing always gives rise to a (flat) vector:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">A</span><span class="o">&gt;</span><span class="m">7</span><span class="p">]</span>
<span class="c1">## [1]  8  9 10 11 12</span>
</pre></div>
</div>
<p>It is nothing else than the single-indexer subsetting
involving two flat vectors (a numeric and a logical one).
The <code class="docutils literal notranslate"><span class="pre">dim</span></code> attributes are not considered here.</p>
</div>
<div class="proof proof-type-exercise" id="id24">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.11</span>
        
    </div><div class="proof-content">
<p>Implement your versions of <strong class="command">max.col</strong>,
<strong class="command">lower.tri</strong>, and <strong class="command">upper.tri</strong>.</p>
</div></div></section>
<section id="selecting-based-on-two-column-numeric-matrices">
<h3><span class="section-number">11.2.7. </span>Selecting based on two-column numeric matrices<a class="headerlink" href="#selecting-based-on-two-column-numeric-matrices" title="Link to this heading">¶</a></h3>
<p>We can also index a matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> by a two-column matrix of positive
integers <code class="docutils literal notranslate"><span class="pre">I</span></code>. For instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">cbind</span><span class="p">(</span>
<span class="w">    </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span>
<span class="w">    </span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="p">))</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    1    2</span>
<span class="c1">## [2,]    3    3</span>
<span class="c1">## [3,]    2    2</span>
<span class="c1">## [4,]    1    2</span>
<span class="c1">## [5,]    2    4</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">A[I]</span></code> gives easy access to:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A[</span> <span class="pre">I[1,</span> <span class="pre">1],</span> <span class="pre">I[1,</span> <span class="pre">2]</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[</span> <span class="pre">I[2,</span> <span class="pre">1],</span> <span class="pre">I[2,</span> <span class="pre">2]</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A[</span> <span class="pre">I[3,</span> <span class="pre">1],</span> <span class="pre">I[3,</span> <span class="pre">2]</span> <span class="pre">]</span></code>,</p></li>
<li><p>…</p></li>
</ul>
<p>and so forth. In other words, each row of <code class="docutils literal notranslate"><span class="pre">I</span></code> gives
the coordinates of the elements to extract.
The result is always a flat vector.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>
<span class="c1">## [1]  4  9  5  4 11</span>
</pre></div>
</div>
<p>This is exactly
<code class="docutils literal notranslate"><span class="pre">A[1,</span> <span class="pre">2],</span> <span class="pre">A[3,</span> <span class="pre">3],</span> <span class="pre">A[2,</span> <span class="pre">2],</span> <span class="pre">A[1,</span> <span class="pre">2],</span> <span class="pre">A[2,</span> <span class="pre">4]</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong class="command">which</strong> can also return a list of index matrices:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">which</span><span class="p">(</span><span class="n">A</span><span class="o">&gt;</span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="n">arr.ind</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
<span class="c1">##      row col</span>
<span class="c1">## [1,]   2   3</span>
<span class="c1">## [2,]   3   3</span>
<span class="c1">## [3,]   1   4</span>
<span class="c1">## [4,]   2   4</span>
<span class="c1">## [5,]   3   4</span>
</pre></div>
</div>
<p>Moreover, <strong class="command">arrayInd</strong> converts
flat indexes to multidimensional ones.</p>
</div>
<div class="proof proof-type-exercise" id="id25">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.12</span>
        
    </div><div class="proof-content">
<p>Implement your version of <strong class="command">arrayInd</strong>
and a function performing the inverse operation.</p>
</div></div><div class="proof proof-type-exercise" id="id26">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.13</span>
        
    </div><div class="proof-content">
<p>Write your version of <strong class="command">diag</strong>.</p>
</div></div></section>
<section id="higher-dimensional-arrays">
<h3><span class="section-number">11.2.8. </span>Higher-dimensional arrays<a class="headerlink" href="#higher-dimensional-arrays" title="Link to this heading">¶</a></h3>
<p>For <span class="math">\(d\)</span>-dimensional arrays, indexing can involve up to <span class="math">\(d\)</span> indexes.
It is particularly valuable for arrays with the <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> attribute set
representing contingency tables over a Cartesian product of multiple factors.
The <strong class="program">datasets</strong><code class="code docutils literal notranslate"><span class="pre">::Titanic</span></code> object is
an exemplary four-dimensional table:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">str</span><span class="p">(</span><span class="nf">dimnames</span><span class="p">(</span><span class="n">Titanic</span><span class="p">))</span><span class="w">  </span><span class="c1"># for reference (note that dimnames are named)</span>
<span class="c1">## List of 4</span>
<span class="c1">##  $ Class   : chr [1:4] &quot;1st&quot; &quot;2nd&quot; &quot;3rd&quot; &quot;Crew&quot;</span>
<span class="c1">##  $ Sex     : chr [1:2] &quot;Male&quot; &quot;Female&quot;</span>
<span class="c1">##  $ Age     : chr [1:2] &quot;Child&quot; &quot;Adult&quot;</span>
<span class="c1">##  $ Survived: chr [1:2] &quot;No&quot; &quot;Yes&quot;</span>
</pre></div>
</div>
<p>Here is the number of adult male crew members who survived
the accident:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">Titanic</span><span class="p">[</span><span class="s">&quot;Crew&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Male&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Adult&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Yes&quot;</span><span class="p">]</span>
<span class="c1">## [1] 192</span>
</pre></div>
</div>
<p>Moreover, let’s fetch a slice corresponding to adults
travelling in the first class:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">Titanic</span><span class="p">[</span><span class="s">&quot;1st&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Adult&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">]</span>
<span class="c1">##         Survived</span>
<span class="c1">## Sex       No Yes</span>
<span class="c1">##   Male   118  57</span>
<span class="c1">##   Female   4 140</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id27">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.14</span>
        
    </div><div class="proof-content">
<p>Check if the above four-dimensional array can be indexed using
matrices with four columns.</p>
</div></div></section>
<section id="replacing-elements">
<h3><span class="section-number">11.2.9. </span>Replacing elements<a class="headerlink" href="#replacing-elements" title="Link to this heading">¶</a></h3>
<p>Generally, subsetting drops all attributes except
<code class="docutils literal notranslate"><span class="pre">names</span></code>, <code class="docutils literal notranslate"><span class="pre">dim</span></code>, and <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> (unless it does not make sense otherwise).
The replacement variant of the index operator
modifies vector values but generally preserves all the attributes.
This enables transforming matrix elements like:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">B</span><span class="p">[</span><span class="n">B</span><span class="o">&lt;</span><span class="m">10</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">B</span><span class="o">&lt;</span><span class="m">10</span><span class="p">]</span><span class="o">^</span><span class="m">2</span><span class="w">  </span><span class="c1"># `A` has no `dimnames` set</span>
<span class="nf">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="c1">##   x  y  z   w</span>
<span class="c1">## a 1 16 49 100</span>
<span class="c1">## b 4 25 64 121</span>
<span class="c1">## c 9 10 11  12</span>
<span class="n">B</span><span class="p">[]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rep</span><span class="p">(</span><span class="nf">seq_len</span><span class="p">(</span><span class="nf">NROW</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span><span class="w"> </span><span class="nf">NCOL</span><span class="p">(</span><span class="n">B</span><span class="p">))</span><span class="w">  </span><span class="c1"># NOT the same as B &lt;- ...</span>
<span class="nf">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w">  </span><span class="c1"># `dim` and `dimnames` were preserved</span>
<span class="c1">##   x y z w</span>
<span class="c1">## a 1 1 1 1</span>
<span class="c1">## b 2 2 2 2</span>
<span class="c1">## c 3 3 3 3</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id28">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.15</span>
        
    </div><div class="proof-content">
<p>Given a character matrix with entities that can be interpreted
as numbers like:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="s">&quot;2&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;4&quot;</span><span class="p">)))</span>
<span class="c1">##   a   b</span>
<span class="c1">## x &quot;1&quot; &quot;2&quot;</span>
<span class="c1">## y &quot;3&quot; &quot;4&quot;</span>
</pre></div>
</div>
<p>convert it to a numeric matrix with a single line of code.
Preserve all attributes.</p>
</div></div></section>
</section>
<section id="common-operations">
<span id="sec-matrix-op"></span><h2><span class="section-number">11.3. </span>Common operations<a class="headerlink" href="#common-operations" title="Link to this heading">¶</a></h2>
<section id="matrix-transpose">
<h3><span class="section-number">11.3.1. </span>Matrix transpose<a class="headerlink" href="#matrix-transpose" title="Link to this heading">¶</a></h3>
<p>The matrix <em>transpose</em>, mathematically denoted by <span class="math">\(\mathbf{A}^T\)</span>,
is available via a call to <strong class="command">t</strong>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
<span class="c1">## [2,]    4    5    6</span>
<span class="nf">t</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    1    4</span>
<span class="c1">## [2,]    2    5</span>
<span class="c1">## [3,]    3    6</span>
</pre></div>
</div>
<p>Hence, if <span class="math">\(\mathbf{B}=\mathbf{A}^T\)</span>, then it is a matrix such that
<span class="math">\(b_{i,j}=a_{j,i}\)</span>. In other words, in the transposed matrix, rows become
columns, and columns become rows.</p>
<p>For higher-dimensional arrays, a generalised transpose can be obtained
through <strong class="command">aperm</strong> (try permuting the dimensions of <code class="docutils literal notranslate"><span class="pre">Titanic</span></code>).
Also, the conjugate transpose of a complex matrix <span class="math">\(\mathbf{A}\)</span>
is done via <strong class="command">Conj</strong><code class="code docutils literal notranslate"><span class="pre">(</span></code><strong class="command">t</strong><code class="code docutils literal notranslate"><span class="pre">(A))</span></code>.</p>
</section>
<section id="vectorised-mathematical-functions">
<h3><span class="section-number">11.3.2. </span>Vectorised mathematical functions<a class="headerlink" href="#vectorised-mathematical-functions" title="Link to this heading">¶</a></h3>
<p>Vectorised functions such as
<strong class="command">sqrt</strong>,
<strong class="command">abs</strong>,
<strong class="command">round</strong>,
<strong class="command">log</strong>,
<strong class="command">exp</strong>,
<strong class="command">cos</strong>,
<strong class="command">sin</strong>,
etc.,
operate on each array element<a class="footnote-reference brackets" href="#footunarymatrix" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">/</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">),</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">)</span>
<span class="nf">round</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w">  </span><span class="c1"># rounds every element in A</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]  1.0 0.33 0.20</span>
<span class="c1">## [2,]  0.5 0.25 0.17</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id29">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.16</span>
        
    </div><div class="proof-content">
<p>Using a single call to <strong class="command">matplot</strong>, which allows
the <code class="docutils literal notranslate"><span class="pre">y</span></code> argument to be a matrix, draw a plot
of <span class="math">\(\sin(x)\)</span>, <span class="math">\(\cos(x)\)</span>, <span class="math">\(|\sin(x)|\)</span>, and <span class="math">\(|\cos(x)|\)</span>
for <span class="math">\(x\in[-2\pi, 6\pi]\)</span>; see <a class="reference internal" href="250-graphics.html#sec-high-level-plotting"><span class="std std-numref">Section 13.3</span></a>
for more details.</p>
</div></div></section>
<section id="aggregating-rows-and-columns">
<h3><span class="section-number">11.3.3. </span>Aggregating rows and columns<a class="headerlink" href="#aggregating-rows-and-columns" title="Link to this heading">¶</a></h3>
<p>When we call an aggregation function on an array,
it will reduce all elements to a single number:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="c1">## [2,]    5    6    7    8</span>
<span class="c1">## [3,]    9   10   11   12</span>
<span class="nf">mean</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="c1">## [1] 6.5</span>
</pre></div>
</div>
<p>The <strong class="command">apply</strong> function may be used to summarise
individual rows or columns in a matrix:</p>
<ul class="simple">
<li><p><strong class="command">apply</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">1,</span> <span class="pre">f)</span></code> applies a given function <strong class="command">f</strong>
on each <em>row</em> of a matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> (over the first axis),</p></li>
<li><p><strong class="command">apply</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">2,</span> <span class="pre">f)</span></code> applies <strong class="command">f</strong>
on each <em>column</em> of <code class="docutils literal notranslate"><span class="pre">A</span></code> (over the second axis).</p></li>
</ul>
<p>For instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w">  </span><span class="c1"># synonym: rowMeans(A)</span>
<span class="c1">## [1]  2.5  6.5 10.5</span>
<span class="nf">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w">  </span><span class="c1"># synonym: colMeans(A)</span>
<span class="c1">## [1] 5 6 7 8</span>
</pre></div>
</div>
<p>The function being applied does not have to return a single number:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">range</span><span class="p">)</span><span class="w">  </span><span class="c1"># min and max</span>
<span class="c1">##      [,1] [,2] [,3] [,4]</span>
<span class="c1">## [1,]    1    2    3    4</span>
<span class="c1">## [2,]    9   10   11   12</span>
<span class="nf">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nf">function</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">Min</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="w"> </span><span class="n">Mean</span><span class="o">=</span><span class="nf">mean</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="w"> </span><span class="n">Max</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## Min   1.0  5.0  9.0</span>
<span class="c1">## Mean  2.5  6.5 10.5</span>
<span class="c1">## Max   4.0  8.0 12.0</span>
</pre></div>
</div>
<p>Take note of the columnwise order of the output values.</p>
<p><strong class="command">apply</strong> also works on higher-dimensional arrays:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">apply</span><span class="p">(</span><span class="n">Titanic</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w">  </span><span class="c1"># over the first axis, &quot;Class&quot; (dimnames works too)</span>
<span class="c1">##     1st     2nd     3rd    Crew</span>
<span class="c1">##  40.625  35.625  88.250 110.625</span>
<span class="nf">apply</span><span class="p">(</span><span class="n">Titanic</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w">  </span><span class="c1"># over c(&quot;Class&quot;, &quot;Age&quot;)</span>
<span class="c1">##       Age</span>
<span class="c1">## Class  Child  Adult</span>
<span class="c1">##   1st   1.50  79.75</span>
<span class="c1">##   2nd   6.00  65.25</span>
<span class="c1">##   3rd  19.75 156.75</span>
<span class="c1">##   Crew  0.00 221.25</span>
</pre></div>
</div>
</section>
<section id="binary-operators">
<span id="sec-recycling-rule-revisited"></span><h3><span class="section-number">11.3.4. </span>Binary operators<a class="headerlink" href="#binary-operators" title="Link to this heading">¶</a></h3>
<p>In <a class="reference internal" href="150-indexing.html#sec-attrpreserv"><span class="std std-numref">Section 5.5</span></a>, we stated that
binary elementwise operations, such as addition or multiplication,
preserve the attributes of the longer input or both (with the first argument preferred to the second) if they are of equal sizes.
Taking into account that:</p>
<ul class="simple">
<li><p>an array is simply a flat vector equipped with the <code class="docutils literal notranslate"><span class="pre">dim</span></code> attribute, and</p></li>
<li><p>we refer to the respective <em>default</em> methods when applying binary
operators,</p></li>
</ul>
<p>we can deduce how `<strong class="command">+</strong>`, `<strong class="command">&lt;=</strong>`,
`<strong class="command">&amp;</strong>`, etc. behave in several different contexts.</p>
<div style="margin-top: 1em"></div><p><strong>Array-array.</strong>
First, let’s note what happens when we operate on two arrays
of identical dimensionalities.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">-10</span><span class="p">,</span><span class="w"> </span><span class="m">-100</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1   10  100</span>
<span class="c1">## [2,]   -1  -10 -100</span>
<span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">2</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1    2    3</span>
<span class="c1">## [2,]    4    5    6</span>
<span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w">  </span><span class="c1"># elementwise addition</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    2   12  103</span>
<span class="c1">## [2,]    3   -5  -94</span>
<span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="w">  </span><span class="c1"># elementwise multiplication (not: algebraic matrix multiply)</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1   20  300</span>
<span class="c1">## [2,]   -4  -50 -600</span>
</pre></div>
</div>
<p>They are simply the addition and multiplication of the corresponding
elements of two given matrices.</p>
<div style="margin-top: 1em"></div><p><strong>Array-scalar</strong>.
Second, we can apply matrix-scalar operations:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="m">-1</span><span class="p">)</span><span class="o">*</span><span class="n">B</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]   -1   -2   -3</span>
<span class="c1">## [2,]   -4   -5   -6</span>
<span class="n">A</span><span class="o">^</span><span class="m">2</span>
<span class="c1">##      [,1] [,2]  [,3]</span>
<span class="c1">## [1,]    1  100 10000</span>
<span class="c1">## [2,]    1  100 10000</span>
</pre></div>
</div>
<p>They multiplied each element in <code class="docutils literal notranslate"><span class="pre">B</span></code> by -1
and squared every element in <code class="docutils literal notranslate"><span class="pre">A</span></code>, respectively.</p>
<p>The behaviour of relational operators is of course similar:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m">100</span>
<span class="c1">##       [,1]  [,2]  [,3]</span>
<span class="c1">## [1,]  TRUE  TRUE  TRUE</span>
<span class="c1">## [2,] FALSE FALSE FALSE</span>
</pre></div>
</div>
<div style="margin-top: 1em"></div><p><strong>Array-vector</strong>.
Next, based on the recycling rule and the fact that matrix
elements are ordered columnwisely, we have that:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">)</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]   10   20   30</span>
<span class="c1">## [2,]  400  500  600</span>
</pre></div>
</div>
<p>It multiplied every element in the first <em>row</em> by 10 and
each element in the second row by 100.</p>
<p>If we wish to multiply each element in the first, second, …, etc.
<em>column</em> by the first, second, …, etc. value in a vector,
we should <em>not</em> call:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="p">)</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1 2000  300</span>
<span class="c1">## [2,]  400    5 6000</span>
</pre></div>
</div>
<p>but rather:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">t</span><span class="p">(</span><span class="nf">t</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="p">))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1  200 3000</span>
<span class="c1">## [2,]    4  500 6000</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">t</span><span class="p">(</span><span class="nf">apply</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">`*`</span><span class="p">,</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1  200 3000</span>
<span class="c1">## [2,]    4  500 6000</span>
</pre></div>
</div>
<div class="proof proof-type-exercise" id="id30">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.17</span>
        
    </div><div class="proof-content">
<p>Write a function that standardises the values in each column of
a given matrix: for all elements in each column,
subtract their mean and then divide them by the standard deviation.
Try to implement it in a few different ways,
including via a call to <strong class="command">apply</strong>,
<strong class="command">sweep</strong>, <strong class="command">scale</strong>, or based solely
on arithmetic operators.</p>
</div></div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some sanity checks are done on the <code class="docutils literal notranslate"><span class="pre">dim</span></code> attributes, so not every
configuration is possible. Notice some peculiarities:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="w">  </span><span class="c1"># `dim` equal to c(2, 3) vs c(3, 2)</span>
<span class="c1">## Error in A + t(B): non-conformable arrays</span>
<span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">cbind</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">)</span><span class="w">  </span><span class="c1"># this is too good to be true</span>
<span class="c1">## Error in A * cbind(1, 10, 100): non-conformable arrays</span>
<span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">)</span><span class="w">  </span><span class="c1"># but A * c(1, 10) works...</span>
<span class="c1">## Error in A * rbind(1, 10): non-conformable arrays</span>
<span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="w">  </span><span class="c1"># `A` has six elements</span>
<span class="c1">## Error in eval(expr, envir, enclos): dims [product 6] do not match the</span>
<span class="c1">##     length of object [12]</span>
<span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="w">  </span><span class="c1"># partial recycling is okay</span>
<span class="c1">## Warning in A + 1:5: longer object length is not a multiple of shorter</span>
<span class="c1">##     object length</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    2   13  105</span>
<span class="c1">## [2,]    1   -6  -99</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="numerical-matrix-algebra">
<h2><span class="section-number">11.4. </span>Numerical matrix algebra (*)<a class="headerlink" href="#numerical-matrix-algebra" title="Link to this heading">¶</a></h2>
<p>Many data analysis and machine learning algorithms, in their essence,
involve rather straightforward matrix algebra and numerical mathematics.
Suffice it to say that anyone serious about data science and scientific
computing should learn the necessary theory;
see, for example, <span id="id5">[<a class="reference internal" href="999-bibliography.html#id42" title="Gentle, J.E. (2007).  Matrix Algebra. Springer.">30</a>]</span> and <span id="id6">[<a class="reference internal" href="999-bibliography.html#id41" title="Gentle, J.E. (2009).  Computational Statistics. Springer.">31</a>]</span>.</p>
<p>R is a convenient interface to the stable and well-tested algorithms from,
amongst others, <code class="docutils literal notranslate"><span class="pre">LAPACK</span></code> and <code class="docutils literal notranslate"><span class="pre">BLAS</span></code><a class="footnote-reference brackets" href="#footblas" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>. Below we mention a few of
them. External packages implement hundreds of algorithms tackling
differential equations, constrained and unconstrained optimisation, etc.;
<a class="reference external" href="https://cran.r-project.org/web/views">CRAN Task Views</a> provide a good
overview.</p>
<section id="matrix-multiplication">
<h3><span class="section-number">11.4.1. </span>Matrix multiplication<a class="headerlink" href="#matrix-multiplication" title="Link to this heading">¶</a></h3>
<p>`<strong class="command">*</strong>` performs <em>elementwise</em> multiplication.
For what we call the (algebraic) <em>matrix</em> multiplication,
we use the `<strong class="command">%*%</strong>` operator. It can only be performed
on two matrices of <em>compatible sizes</em>:
the number of columns in the left matrix must match
the number of rows in the right operand.</p>
<p>Given <span class="math">\(\mathbf{A}\in\mathbb{R}^{n\times p}\)</span>
and <span class="math">\(\mathbf{B}\in\mathbb{R}^{p\times m}\)</span>, their multiply is a matrix
<span class="math">\(\mathbf{C}=\mathbf{A}\mathbf{B}\in\mathbb{R}^{n\times m}\)</span>
such that <span class="math">\(c_{i,j}\)</span> is the dot product of the <span class="math">\(i\)</span>-th row in <span class="math">\(\mathbf{A}\)</span>
and the <span class="math">\(j\)</span>-th column in <span class="math">\(\mathbf{B}\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
c_{i,j} = \mathbf{a}_{i,\cdot} \cdot \mathbf{b}_{\cdot,j}
= \sum_{k=1}^p a_{i,k} b_{k, j},
\]</div>
</div>
<p>for <span class="math">\(i=1,\dots,n\)</span> and <span class="math">\(j=1,\dots,m\)</span>.
For instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">-2</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    0    1    3</span>
<span class="c1">## [2,]   -1    1   -2</span>
<span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    3   -1</span>
<span class="c1">## [2,]    1    2</span>
<span class="c1">## [3,]    6    1</span>
<span class="n">A</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">B</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]   19    5</span>
<span class="c1">## [2,]  -14    1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When applying `<strong class="command">%*%</strong>` on one or more flat vectors,
their dimensionality will be promoted automatically to make
the operation possible. However,
<strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span> </code><strong class="command">%*%</strong><code class="code docutils literal notranslate"> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">d)</span></code>
gives a scalar <span class="math">\(ac+bd\)</span>, and not a <span class="math">\(2\times 2\)</span> matrix.</p>
</div>
<p>Further,
<strong class="command">crossprod</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">B)</span></code> yields <span class="math">\(\mathbf{A}^T \mathbf{B}\)</span> and
<strong class="command">tcrossprod</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">B)</span></code> determines <span class="math">\(\mathbf{A} \mathbf{B}^T\)</span>
more efficiently than relying on `<strong class="command">%*%</strong>`.
We can omit the second argument and get
<span class="math">\(\mathbf{A}^T \mathbf{A}\)</span> and <span class="math">\(\mathbf{A} \mathbf{A}^T\)</span>, respectively.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">crossprod</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w">  </span><span class="c1"># Euclidean norm squared</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    5</span>
<span class="nf">crossprod</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">))</span><span class="w">  </span><span class="c1"># dot product of two vectors</span>
<span class="c1">##      [,1]</span>
<span class="c1">## [1,]    0</span>
<span class="nf">crossprod</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="w">  </span><span class="c1"># same as t(A) %*% A, i.e., dot products of all column pairs</span>
<span class="c1">##      [,1] [,2] [,3]</span>
<span class="c1">## [1,]    1   -1    2</span>
<span class="c1">## [2,]   -1    2    1</span>
<span class="c1">## [3,]    2    1   13</span>
</pre></div>
</div>
<p>Recall that if the dot product of two vectors equals 0,
we say that they are orthogonal (perpendicular).</p>
<div class="proof proof-type-exercise" id="id31">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.18</span>
        
    </div><div class="proof-content">
<p>(*)
Write your versions of <strong class="command">cov</strong> and <strong class="command">cor</strong>:
functions to compute the covariance and correlation matrices.
Make use of the fact that the former can be determined
with <strong class="command">crossprod</strong> based on a centred version of an input matrix.</p>
</div></div></section>
<section id="solving-systems-of-linear-equations">
<h3><span class="section-number">11.4.2. </span>Solving systems of linear equations<a class="headerlink" href="#solving-systems-of-linear-equations" title="Link to this heading">¶</a></h3>
<p>The <strong class="command">solve</strong> function can be used to determine the
solution to <span class="math">\(m\)</span> systems of <span class="math">\(n\)</span> linear equations of the form
<span class="math">\(\mathbf{A}\mathbf{X}=\mathbf{B}\)</span>,
where <span class="math">\(\mathbf{A}\in\mathbb{R}^{n\times n}\)</span> and <span class="math">\(\mathbf{X},\mathbf{B}\in\mathbb{R}^{n\times m}\)</span>
(via the LU decomposition with partial pivoting and row interchanges).</p>
</section>
<section id="norms-and-metrics">
<h3><span class="section-number">11.4.3. </span>Norms and metrics<a class="headerlink" href="#norms-and-metrics" title="Link to this heading">¶</a></h3>
<p>Given an <span class="math">\(n\times m\)</span> matrix <span class="math">\(\mathbf{A}\)</span>, calling
<strong class="command">norm</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">&quot;1&quot;)</span></code>,
<strong class="command">norm</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">&quot;2&quot;)</span></code>,
and <strong class="command">norm</strong><code class="code docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">&quot;I&quot;)</span></code>,
we can compute the operator norms:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
\begin{array}{lcl}
\|\mathbf{A}\|_1 &=& \max_{j=1,\dots,m} \sum_{i=1}^n |a_{i,j}|,\\
\|\mathbf{A}\|_2 &=& \sigma_1(\mathbf{A}) = \sup_{\mathbf{0}\neq\mathbf{x}\in\mathbb{R}^m}
                      \frac{\|\mathbf{A}\mathbf{x}\|_2}{\|\mathbf{x}\|_2} \\
\|\mathbf{A}\|_I &=& \max_{i=1,\dots,n} \sum_{j=1}^m |a_{i,j}|,\\
\end{array}
\]</div>
</div>
<p>where <span class="math">\(\sigma_1\)</span> gives the largest singular value (see below).</p>
<p>Also, passing <code class="docutils literal notranslate"><span class="pre">&quot;F&quot;</span></code> as the second argument
yields the Frobenius norm,
<span class="math">\(\|\mathbf{A}\|_F = \sqrt{\sum_{i=1}^n \sum_{j=1}^m a_{i,j}^2}\)</span>,
and <code class="docutils literal notranslate"><span class="pre">&quot;M&quot;</span></code> computes the maximum norm,
<span class="math">\(\|\mathbf{A}\|_M = \max_{{i=1,\dots,n\atop j=1,\dots,m}} |a_{i,j}|\)</span>.</p>
<p>If <span class="math">\(\mathbf{A}\)</span> is a column vector, then
<span class="math">\(\|\mathbf{A}\|_F\)</span> and <span class="math">\(\|\mathbf{A}\|_2\)</span> are equivalent.
They are referred to as the Euclidean norm.
Moreover, <span class="math">\(\|\mathbf{A}\|_M=\|\mathbf{A}\|_I\)</span> gives the supremum norm
and <span class="math">\(\|\mathbf{A}\|_1\)</span> outputs the Manhattan (taxicab) one.</p>
<div class="proof proof-type-exercise" id="id32">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.19</span>
        
    </div><div class="proof-content">
<p>Given an <span class="math">\(n\times m\)</span> matrix <span class="math">\(\mathbf{A}\)</span>, normalise each column
so that it becomes a unit vector, i.e., whose Euclidean norm equals 1.</p>
</div></div><p>Further, <strong class="command">dist</strong> determines all pairwise distances
between a set of <span class="math">\(n\)</span> vectors in <span class="math">\(\mathbb{R}^m\)</span>,
written as an <span class="math">\(n\times m\)</span> matrix.
For example, let’s consider three vectors in <span class="math">\(\mathbb{R}^2\)</span>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">-2</span><span class="p">),</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)))</span>
<span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    1    1</span>
<span class="c1">## [2,]    1   -2</span>
<span class="c1">## [3,]    0    0</span>
<span class="nf">as.matrix</span><span class="p">(</span><span class="nf">dist</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;euclidean&quot;</span><span class="p">))</span>
<span class="c1">##        1      2      3</span>
<span class="c1">## 1 0.0000 3.0000 1.4142</span>
<span class="c1">## 2 3.0000 0.0000 2.2361</span>
<span class="c1">## 3 1.4142 2.2361 0.0000</span>
</pre></div>
</div>
<p>Thus, the Euclidean distance between the first and the third vector,
<span class="math">\(\|\mathbf{x}_{1,\cdot}-\mathbf{x}_{3,\cdot}\|_2=\sqrt{ (x_{1,1}-x_{3,1})^2 + (x_{1,2}-x_{3,2})^2 }\)</span>,
is roughly 1.41421.
The maximum, Manhattan, and Canberra distances/metrics
are also available, amongst others.</p>
<div class="proof proof-type-exercise" id="id33">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.20</span>
        
    </div><div class="proof-content">
<p><strong class="command">dist</strong> returns an object of the S3 class <code class="docutils literal notranslate"><span class="pre">dist</span></code>.
Inspect how it is represented.</p>
</div></div><div class="proof proof-type-example" id="id34">

    <div class="proof-title">
        <span class="proof-type">Example 11.21</span>
        
    </div><div class="proof-content">
<p><strong class="command">adist</strong> implements a couple of string metrics.
For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;spam&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bacon&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;eggs&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spa&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;spams&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;legs&quot;</span><span class="p">)</span>
<span class="nf">names</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">x</span>
<span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">adist</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1">##       spam bacon eggs spa spams legs</span>
<span class="c1">## spam     0     5    4   1     1    4</span>
<span class="c1">## bacon    5     0    5   5     5    5</span>
<span class="c1">## eggs     4     5    0   4     4    2</span>
<span class="c1">## spa      1     5    4   0     2    4</span>
<span class="c1">## spams    1     5    4   2     0    4</span>
<span class="c1">## legs     4     5    2   4     4    0</span>
</pre></div>
</div>
<p>It gave the Levenshtein distances between each pair of strings.
In particular, we need two edit operations (character
insertions, deletions, or replacements) to turn <code class="docutils literal notranslate"><span class="pre">&quot;eggs&quot;</span></code> into <code class="docutils literal notranslate"><span class="pre">&quot;legs&quot;</span></code>
(add <code class="docutils literal notranslate"><span class="pre">l</span></code> and remove <code class="docutils literal notranslate"><span class="pre">g</span></code>).</p>
</div></div><div class="proof proof-type-example" id="id35">

    <div class="proof-title">
        <span class="proof-type">Example 11.22</span>
        
    </div><div class="proof-content">
<p>Objects of the class <code class="docutils literal notranslate"><span class="pre">dist</span></code> can be used to find a hierarchical
clustering of a dataset. For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">hclust</span><span class="p">(</span><span class="nf">as.dist</span><span class="p">(</span><span class="n">d</span><span class="p">),</span><span class="w"> </span><span class="n">method</span><span class="o">=</span><span class="s">&quot;average&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># see also: plot(h, labels=x)</span>
<span class="nf">cutree</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)</span>
<span class="c1">##  spam bacon  eggs   spa spams  legs</span>
<span class="c1">##     1     2     3     1     1     3</span>
</pre></div>
</div>
<p>It determined three clusters using the average linkage strategy
(<code class="docutils literal notranslate"><span class="pre">&quot;legs&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;eggs&quot;</span></code> are grouped together, <code class="docutils literal notranslate"><span class="pre">&quot;spam&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;spa&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;spams&quot;</span></code>
form another cluster, and <code class="docutils literal notranslate"><span class="pre">&quot;bacon&quot;</span></code> is a singleton).</p>
</div></div></section>
<section id="eigenvalues-and-eigenvectors">
<h3><span class="section-number">11.4.4. </span>Eigenvalues and eigenvectors<a class="headerlink" href="#eigenvalues-and-eigenvectors" title="Link to this heading">¶</a></h3>
<p><strong class="command">eigen</strong> returns a sequence of eigenvalues
<span class="math">\((\lambda_1,\dots,\lambda_n)\)</span>
ordered nondecreasingly w.r.t. <span class="math">\(|\lambda_i|\)</span>,
and a matrix <span class="math">\(\mathbf{V}\)</span> whose columns define the corresponding
eigenvectors (scaled to the unit length) of a given matrix <span class="math">\(\mathbf{X}\)</span>.
By definition, for all <span class="math">\(j\)</span>, we have
<span class="math">\(\mathbf{X}\mathbf{v}_{\cdot,j}=\lambda_j \mathbf{v}_{\cdot,j}\)</span>.</p>
<div class="proof proof-type-example" id="id36">

    <div class="proof-title">
        <span class="proof-type">Example 11.23</span>
        
    </div><div class="proof-content">
<p>(*)
Here are the eigenvalues and the corresponding eigenvectors
of the matrix defining the rotation in the xy-plane
about the origin <span class="math">\((0, 0)\)</span> by the counterclockwise angle <span class="math">\(\pi/6\)</span>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">R</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="kc">pi</span><span class="o">/</span><span class="m">6</span><span class="p">),</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="kc">pi</span><span class="o">/</span><span class="m">6</span><span class="p">)),</span>
<span class="w">            </span><span class="nf">c</span><span class="p">(</span><span class="o">-</span><span class="nf">sin</span><span class="p">(</span><span class="kc">pi</span><span class="o">/</span><span class="m">6</span><span class="p">),</span><span class="w"> </span><span class="nf">cos</span><span class="p">(</span><span class="kc">pi</span><span class="o">/</span><span class="m">6</span><span class="p">))))</span>
<span class="c1">##          [,1]    [,2]</span>
<span class="c1">## [1,]  0.86603 0.50000</span>
<span class="c1">## [2,] -0.50000 0.86603</span>
<span class="nf">eigen</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="c1">## eigen() decomposition</span>
<span class="c1">## $values</span>
<span class="c1">## [1] 0.86603+0.5i 0.86603-0.5i</span>
<span class="c1">##</span>
<span class="c1">## $vectors</span>
<span class="c1">##                  [,1]             [,2]</span>
<span class="c1">## [1,] 0.70711+0.00000i 0.70711+0.00000i</span>
<span class="c1">## [2,] 0.00000+0.70711i 0.00000-0.70711i</span>
</pre></div>
</div>
<p>The complex eigenvalues are <span class="math">\(e^{-\pi/6 i}\)</span> and <span class="math">\(e^{\pi/6 i}\)</span>
and we have <span class="math">\(|e^{-\pi/6 i}|=|e^{\pi/6 i}|=1\)</span>.</p>
</div></div><div class="proof proof-type-example" id="id37">

    <div class="proof-title">
        <span class="proof-type">Example 11.24</span>
        
    </div><div class="proof-content">
<p>(*)
Consider a pseudorandom sample that we depict in
<a class="reference internal" href="#fig-eigen-prcomp-1"><span class="std std-numref">Figure 11.1</span></a>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">rbind</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="nf">sqrt</span><span class="p">(</span><span class="m">5</span><span class="p">),</span><span class="w">      </span><span class="m">0</span><span class="w"> </span><span class="p">),</span>
<span class="w">           </span><span class="nf">c</span><span class="p">(</span><span class="w">     </span><span class="m">0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nf">sqrt</span><span class="p">(</span><span class="m">2</span><span class="p">)))</span>
<span class="n">mu</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="m">-3</span><span class="p">)</span>
<span class="n">Z</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="nf">rnorm</span><span class="p">(</span><span class="m">2000</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">  </span><span class="c1"># each row is a standard normal 2-vector</span>
<span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="nf">t</span><span class="p">(</span><span class="n">Z</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span><span class="w">  </span><span class="c1"># scale, rotate, shift</span>
<span class="nf">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">asp</span><span class="o">=</span><span class="m">1</span><span class="p">)</span><span class="w">  </span><span class="c1"># scatter plot</span>
<span class="c1"># draw principal axes:</span>
<span class="n">A</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="nf">t</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">ncol</span><span class="o">=</span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span>
<span class="nf">arrows</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">col</span><span class="o">=</span><span class="s">&quot;red&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lwd</span><span class="o">=</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="o">=</span><span class="m">0.1</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default" id="id38">
<span id="fig-eigen-prcomp-1"></span><img alt="../_images/eigen-prcomp-1-1.png" src="../_images/eigen-prcomp-1-1.png" />
<figcaption>
<p><span class="caption-number">Figure 11.1 </span><span class="caption-text">A sample from a bivariate normal distribution and its principal axes.</span><a class="headerlink" href="#id38" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><span class="math">\(\mathbf{X}\)</span> was created by generating a realisation of a two-dimensional
standard normal vector <span class="math">\(\mathbf{Z}\)</span>,
scaling it by <span class="math">\(\left(\sqrt{5}, \sqrt{2}\right)\)</span>,
rotating by the counterclockwise
angle <span class="math">\(\pi/6\)</span>, and shifting by <span class="math">\((10, -3)\)</span>, which we denote by
<span class="math">\(\mathbf{X}=\mathbf{Z} \mathbf{S} \mathbf{R} + \boldsymbol{\mu}^T\)</span>.
It follows a bivariate<a class="footnote-reference brackets" href="#footcopula" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> normal
distribution centred at <span class="math">\(\boldsymbol{\mu}=(10, -3)\)</span> and
with the covariance matrix
<span class="math">\(\boldsymbol{\Sigma}=(\mathbf{S} \mathbf{R})^T (\mathbf{S} \mathbf{R})\)</span>:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">crossprod</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">R</span><span class="p">)</span><span class="w">  </span><span class="c1"># covariance matrix</span>
<span class="c1">##       [,1]  [,2]</span>
<span class="c1">## [1,] 4.250 1.299</span>
<span class="c1">## [2,] 1.299 2.750</span>
<span class="nf">cov</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="w">  </span><span class="c1"># compare: sample covariance matrix (estimator)</span>
<span class="c1">##        [,1]   [,2]</span>
<span class="c1">## [1,] 4.1965 1.2386</span>
<span class="c1">## [2,] 1.2386 2.7973</span>
</pre></div>
</div>
<p>It is known that eigenvectors of the covariance matrix
correspond to the principal components of the original dataset.
Furthermore, its eigenvalues give the variances explained by each of them.</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">eigen</span><span class="p">(</span><span class="nf">cov</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="c1">## eigen() decomposition</span>
<span class="c1">## $values</span>
<span class="c1">## [1] 4.9195 2.0744</span>
<span class="c1">##</span>
<span class="c1">## $vectors</span>
<span class="c1">##          [,1]     [,2]</span>
<span class="c1">## [1,] -0.86366  0.50408</span>
<span class="c1">## [2,] -0.50408 -0.86366</span>
</pre></div>
</div>
<p>It roughly corresponds to the principal directions
<span class="math">\((\cos \pi/6, \sin \pi/6 )\simeq (0.866, 0.5)\)</span>
and the thereto-orthogonal
<span class="math">\((-\sin \pi/6,  \cos \pi/6 )\simeq (-0.5, 0.866)\)</span>
(up to an orientation inverse)
with the corresponding variances of <span class="math">\(5\)</span> and <span class="math">\(2\)</span>
(i.e., standard deviations of <span class="math">\(\sqrt{5}\)</span> and <span class="math">\(\sqrt{2}\)</span>), respectively.
Note that this method of performing principal component analysis, i.e.,
recreating the scale and rotation transformation applied on <span class="math">\(\mathbf{Z}\)</span>
based only on <span class="math">\(\mathbf{X}\)</span>, is not particularly numerically stable;
see below for an alternative.</p>
</div></div></section>
<section id="qr-decomposition">
<h3><span class="section-number">11.4.5. </span>QR decomposition<a class="headerlink" href="#qr-decomposition" title="Link to this heading">¶</a></h3>
<p>We say that a real <span class="math">\(n\times m\)</span> matrix <span class="math">\(\mathbf{Q}\)</span>, <span class="math">\(n\ge m\)</span>,
is <em>orthogonal</em>, whenever <span class="math">\(\mathbf{Q}^T \mathbf{Q}  = \mathbf{I}\)</span>
(identity matrix). This is equivalent to <span class="math">\(\mathbf{Q}\)</span>’s columns’ being
orthogonal unit vectors. Also,
if <span class="math">\(\mathbf{Q}\)</span> is a square matrix, then
<span class="math">\(\mathbf{Q}^T=\mathbf{Q}^{-1}\)</span> if and only if
<span class="math">\(\mathbf{Q}^T \mathbf{Q} = \mathbf{Q} \mathbf{Q}^T = \mathbf{I}\)</span>.</p>
<p>Let <span class="math">\(\mathbf{A}\)</span> be a real<a class="footnote-reference brackets" href="#footcomplexqr" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a> <span class="math">\(n\times m\)</span> matrix with <span class="math">\(n\ge m\)</span>.
Then <span class="math">\(\mathbf{A}=\mathbf{Q}\mathbf{R}\)</span> is its QR
decomposition (in the so-called narrow form),
if <span class="math">\(\mathbf{Q}\)</span> is an orthogonal <span class="math">\(n\times m\)</span> matrix
and <span class="math">\(\mathbf{R}\)</span> is an upper triangular
<span class="math">\(m\times m\)</span> one.</p>
<p>The <strong class="command">qr</strong> function returns an object of the S3 class <code class="docutils literal notranslate"><span class="pre">qr</span></code>
from which we can extract  the two components; see the
<strong class="command">qr.Q</strong> and <strong class="command">qr.R</strong> functions.</p>
<div class="proof proof-type-example" id="id39">

    <div class="proof-title">
        <span class="proof-type">Example 11.25</span>
        
    </div><div class="proof-content">
<p>Let <span class="math">\(\mathbf{X}\)</span> be an <span class="math">\(n\times m\)</span> data matrix, representing
<span class="math">\(n\)</span> points in <span class="math">\(\mathbb{R}^m\)</span>, and a vector
<span class="math">\(\mathbf{y}\in\mathbb{R}^n\)</span> of the <em>desired</em> outputs corresponding
to each input.
For fitting a linear model <span class="math">\(\mathbf{x}^T \boldsymbol\theta\)</span>,
where <span class="math">\(\boldsymbol\theta\)</span> is a vector of <span class="math">\(m\)</span> parameters,
we can use the method of least squares, which minimises:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
\mathcal{L}(\boldsymbol\theta) = \sum_{i=1}^n \left(
\mathbf{x}_{i,\cdot}^T \boldsymbol\theta  - y_i
\right)^2
=
\|\mathbf{X} \boldsymbol\theta - \mathbf{y}\|_2^2.
\]</div>
</div>
<p>It might be shown that if
<span class="math">\(\mathbf{X}=\mathbf{Q}\mathbf{R}\)</span>,
then <span class="math">\(\boldsymbol\theta =
\left(\mathbf{X}^T \mathbf{X} \right)^{-1} \mathbf{X}^T \mathbf{y}
= \mathbf{R}^{-1}\mathbf{Q}^T\mathbf{y}\)</span>, which can conveniently
be determined via a call to <strong class="command">qr.coef</strong>.</p>
<p>In particular, we can fit a simple linear regression
model <span class="math">\(y=ax+b\)</span> by considering <span class="math">\(\mathbf{X} = (x, 1)\)</span> and
<span class="math">\(\boldsymbol\theta = (a, b)\)</span>.
For instance (see <a class="reference internal" href="#fig-qr-lm"><span class="std std-numref">Figure 11.2</span></a>):</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cars</span><span class="p">[[</span><span class="s">&quot;speed&quot;</span><span class="p">]]</span>
<span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">cars</span><span class="p">[[</span><span class="s">&quot;dist&quot;</span><span class="p">]]</span>
<span class="n">X1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">cbind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">  </span><span class="c1"># the model is theta[1]*x + theta[2]*1</span>
<span class="n">qrX1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">qr</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>
<span class="p">(</span><span class="n">theta</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="nf">qr.R</span><span class="p">(</span><span class="n">qrX1</span><span class="p">))</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="nf">qr.Q</span><span class="p">(</span><span class="n">qrX1</span><span class="p">))</span><span class="w"> </span><span class="o">%*%</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">  </span><span class="c1"># or: qr.coef(qrX1, y)</span>
<span class="c1">##       [,1]</span>
<span class="c1">## x   3.9324</span>
<span class="c1">##   -17.5791</span>
<span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">xlab</span><span class="o">=</span><span class="s">&quot;speed&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ylab</span><span class="o">=</span><span class="s">&quot;dist&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># scatter plot</span>
<span class="nf">abline</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="m">2</span><span class="p">],</span><span class="w"> </span><span class="n">theta</span><span class="p">[</span><span class="m">1</span><span class="p">],</span><span class="w"> </span><span class="n">lty</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="w">  </span><span class="c1"># add the regression line</span>
</pre></div>
</div>
<figure class="align-default" id="id40">
<span id="fig-qr-lm"></span><img alt="../_images/qr-lm-1.png" src="../_images/qr-lm-1.png" />
<figcaption>
<p><span class="caption-number">Figure 11.2 </span><span class="caption-text">The <code class="docutils literal notranslate"><span class="pre">cars</span></code> dataset and the fitted regression line.</span><a class="headerlink" href="#id40" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><strong class="command">solve</strong> with one argument determines the inverse of a given matrix.
The fitted model is <span class="math">\(y=3.93241x-17.5791\)</span>.</p>
<p>The same approach is used by <strong class="command">lm.fit</strong>,
the workhorse behind the <strong class="command">lm</strong> method accepting an R formula
(which some readers might be familiar with; compare <a class="reference internal" href="340-lazy.html#sec-formula"><span class="std std-numref">Section 17.6</span></a>).</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">lm.fit</span><span class="p">(</span><span class="nf">cbind</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">)[[</span><span class="s">&quot;coefficients&quot;</span><span class="p">]]</span><span class="w">  </span><span class="c1"># also: lm(dist~speed, data=cars)</span>
<span class="c1">##        x</span>
<span class="c1">##   3.9324 -17.5791</span>
</pre></div>
</div>
</div></div></section>
<section id="svd-decomposition">
<h3><span class="section-number">11.4.6. </span>SVD decomposition<a class="headerlink" href="#svd-decomposition" title="Link to this heading">¶</a></h3>
<p>Given a real <span class="math">\(n\times m\)</span> matrix <span class="math">\(\mathbf{X}\)</span>,
its singular value decomposition (SVD) is given by
<span class="math">\(\mathbf{X}=\mathbf{U} \mathbf{D} \mathbf{V}^T\)</span>,
where <span class="math">\(\mathbf{D}\)</span> is a <span class="math">\(p\times p\)</span> diagonal matrix
(with the singular values of <span class="math">\(\mathbf{X}\)</span>,
<span class="math">\(d_{1,1}\ge\dots\ge d_{p,p}\ge 0\)</span>, <span class="math">\(p=\min\{n,m\}\)</span>),
and <span class="math">\(\mathbf{U}\)</span> and <span class="math">\(\mathbf{V}\)</span> are orthogonal matrices
of dimensions <span class="math">\(n\times p\)</span> and <span class="math">\(m\times p\)</span>, respectively.</p>
<p><strong class="command">svd</strong> may not only be used to determine the solution to
linear regression<a class="footnote-reference brackets" href="#footregsvd" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>
but also to perform the principal component analysis<a class="footnote-reference brackets" href="#footpcasvd" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.
Namely, <span class="math">\(\mathbf{V}\)</span> gives the eigenvectors of <span class="math">\(\mathbf{X}^T \mathbf{X}\)</span>.
Assuming that <span class="math">\(\mathbf{X}\)</span> is centred at <span class="math">\(\boldsymbol{0}\)</span>,
the latter is precisely its scaled covariance matrix.</p>
<div class="proof proof-type-example" id="id41">

    <div class="proof-title">
        <span class="proof-type">Example 11.26</span>
        
    </div><div class="proof-content">
<p>(*)
Continuing the example featuring a bivariate normal sample,
we can determine the principal directions also by calling:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">Xc</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">t</span><span class="p">(</span><span class="nf">t</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">-</span><span class="nf">colMeans</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="w">  </span><span class="c1"># centred version of X</span>
<span class="nf">svd</span><span class="p">(</span><span class="n">Xc</span><span class="p">)[[</span><span class="s">&quot;v&quot;</span><span class="p">]]</span>
<span class="c1">##          [,1]     [,2]</span>
<span class="c1">## [1,] -0.86366 -0.50408</span>
<span class="c1">## [2,] -0.50408  0.86366</span>
</pre></div>
</div>
</div></div></section>
<section id="a-note-on-the-matrix-package">
<span id="sec-matrix-s4"></span><h3><span class="section-number">11.4.7. </span>A note on the <strong class="program">Matrix</strong> package<a class="headerlink" href="#a-note-on-the-matrix-package" title="Link to this heading">¶</a></h3>
<p>The <strong class="program">Matrix</strong> package is perhaps the most widely known showcase of
the S4 object orientation (<a class="reference internal" href="220-s3.html#sec-s4"><span class="std std-numref">Section 10.5</span></a>). It defines classes and methods
for dense and sparse matrices, including rectangular, symmetric,
triangular, band, and diagonal ones.</p>
<p>For instance, large graph (e.g., in network sciences)
or preference (e.g., in recommender systems) data can be represented
using sparse matrices, i.e., those with many zeroes.
After all, it is much more likely for two vertices in a network
<em>not</em> to be joined by an edge than to be connected.
For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="nf">library</span><span class="p">(</span><span class="s">&quot;Matrix&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">D</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">Diagonal</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">))</span>
<span class="c1">## 5 x 5 diagonal matrix of class &quot;ddiMatrix&quot;</span>
<span class="c1">##      [,1] [,2] [,3] [,4] [,5]</span>
<span class="c1">## [1,]    1    .    .    .    .</span>
<span class="c1">## [2,]    .    2    .    .    .</span>
<span class="c1">## [3,]    .    .    3    .    .</span>
<span class="c1">## [4,]    .    .    .    4    .</span>
<span class="c1">## [5,]    .    .    .    .    5</span>
</pre></div>
</div>
<p>We created a real diagonal matrix of size <span class="math">\(5\times 5\)</span>;
20 elements equal to zero are specially marked. Moreover:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">S</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as</span><span class="p">(</span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;sparseMatrix&quot;</span><span class="p">)</span>
<span class="n">S</span><span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">7</span>
<span class="n">S</span><span class="p">[</span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">42</span>
<span class="nf">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="c1">## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot;</span>
<span class="c1">##</span>
<span class="c1">## [1,]  1 7 . . .</span>
<span class="c1">## [2,]  . 2 . . .</span>
<span class="c1">## [3,]  . . 3 . .</span>
<span class="c1">## [4,] 42 . . 4 .</span>
<span class="c1">## [5,]  . . . . 5</span>
</pre></div>
</div>
<p>It yielded a general sparse real matrix in the CSC
(compressed, sparse, column-orientated) format.</p>
<p>For more information on this package, see
<strong class="command">vignette</strong><code class="code docutils literal notranslate"><span class="pre">(package=&quot;Matrix&quot;)</span></code>.</p>
</section>
</section>
<section id="exercises">
<h2><span class="section-number">11.5. </span>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">¶</a></h2>
<div class="proof proof-type-exercise" id="id42">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.27</span>
        
    </div><div class="proof-content">
<p>Let <code class="docutils literal notranslate"><span class="pre">X</span></code> be a matrix with <code class="docutils literal notranslate"><span class="pre">dimnames</span></code> set. For instance:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="n">byrow</span><span class="o">=</span><span class="kc">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="o">=</span><span class="m">3</span><span class="p">)</span><span class="w">      </span><span class="c1"># example matrix</span>
<span class="nf">dimnames</span><span class="p">(</span><span class="n">X</span><span class="p">)[[</span><span class="m">2</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1"># set column names</span>
<span class="nf">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="c1">##      a  b  c  d</span>
<span class="c1">## [1,] 1  2  3  4</span>
<span class="c1">## [2,] 5  6  7  8</span>
<span class="c1">## [3,] 9 10 11 12</span>
</pre></div>
</div>
<p>Explain the meaning of the following expressions
involving matrix subsetting. Note that a few of them are invalid.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X[1,</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">3]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">3,</span> <span class="pre">drop=FALSE]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[3]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">&quot;a&quot;]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;)]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">-2]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,1]</span> <span class="pre">&gt;</span> <span class="pre">5,</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,1]&gt;5,</span> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;)]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,1]&gt;=5</span> <span class="pre">&amp;</span> <span class="pre">X[,1]&lt;=10,</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,1]&gt;=5</span> <span class="pre">&amp;</span> <span class="pre">X[,1]&lt;=10,</span> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;)]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;d&quot;)]</span></code>.</p></li>
</ul>
</div></div><div class="proof proof-type-exercise" id="id43">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.28</span>
        
    </div><div class="proof-content">
<p>Assuming that <code class="docutils literal notranslate"><span class="pre">X</span></code> is an array, what is the difference between the following
operations involving indexing?</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X[&quot;1&quot;,</span> <span class="pre">]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[1,</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;]</span></code> vs
<code class="docutils literal notranslate"><span class="pre">X[,</span> </code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;)]</span></code> vs
<code class="docutils literal notranslate"><span class="pre">X[</span></code><strong class="command">c</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;a&quot;,</span> <span class="pre">&quot;b&quot;,</span> <span class="pre">&quot;c&quot;)]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[1]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">1]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[1,</span> <span class="pre">]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X&gt;0]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[X&gt;0,</span> <span class="pre">]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[,</span> <span class="pre">X&gt;0]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,</span> <span class="pre">1]&gt;0]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[X[,</span> <span class="pre">1]&gt;0,]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[,X[,1]&gt;0]</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X[X[,</span> <span class="pre">1]&gt;5,</span> <span class="pre">X[1,</span> <span class="pre">]&lt;10]</span></code> vs <code class="docutils literal notranslate"><span class="pre">X[X[1,</span> <span class="pre">]&gt;5,</span> <span class="pre">X[,</span> <span class="pre">1]&lt;10]</span></code>.</p></li>
</ul>
</div></div><div class="proof proof-type-exercise" id="id44">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.29</span>
        
    </div><div class="proof-content">
<p>Give a few ways to create a matrix like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">##      [,1] [,2]</span>
<span class="c1">## [1,]    1    1</span>
<span class="c1">## [2,]    1    2</span>
<span class="c1">## [3,]    1    3</span>
<span class="c1">## [4,]    2    1</span>
<span class="c1">## [5,]    2    2</span>
<span class="c1">## [6,]    2    3</span>
</pre></div>
</div>
<p>and one like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">##       [,1] [,2] [,3]</span>
<span class="c1">##  [1,]    1    1    1</span>
<span class="c1">##  [2,]    1    1    2</span>
<span class="c1">##  [3,]    1    2    1</span>
<span class="c1">##  [4,]    1    2    2</span>
<span class="c1">##  [5,]    1    3    1</span>
<span class="c1">##  [6,]    1    3    2</span>
<span class="c1">##  [7,]    2    1    1</span>
<span class="c1">##  [8,]    2    1    2</span>
<span class="c1">##  [9,]    2    2    1</span>
<span class="c1">## [10,]    2    2    2</span>
<span class="c1">## [11,]    2    3    1</span>
<span class="c1">## [12,]    2    3    2</span>
</pre></div>
</div>
</div></div><div class="proof proof-type-exercise" id="id45">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.30</span>
        
    </div><div class="proof-content">
<p>For a given real <span class="math">\(n\times m\)</span> matrix <span class="math">\(\mathbf{X}\)</span>,
encoding <span class="math">\(n\)</span> input points in an <span class="math">\(m\)</span>-dimensional space,
determine their bounding hyperrectangle, i.e.,
return a <span class="math">\(2\times m\)</span> matrix <span class="math">\(\mathbf{B}\)</span>
with <span class="math">\(b_{1,j}=\min_i x_{i,j}\)</span> and <span class="math">\(b_{2,j}=\max_i x_{i,j}\)</span>.</p>
</div></div><div class="proof proof-type-exercise" id="id46">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.31</span>
        
    </div><div class="proof-content">
<p>Let <span class="math">\(\mathbf{t}\)</span> be a vector of <span class="math">\(n\)</span> integers in <span class="math">\(\{1,\dots,k\}\)</span>.
Write a function to one-hot encode each <span class="math">\(t_i\)</span>.
Return a 0–1 matrix <span class="math">\(\mathbf{R}\)</span> of size <span class="math">\(n\times k\)</span> such that <span class="math">\(r_{i,j}=1\)</span>
if and only if <span class="math">\(j = t_i\)</span>.
For example, if <span class="math">\(\mathbf{t}=[1, 2, 3, 2, 4]\)</span> and <span class="math">\(k=4\)</span>, then:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
\mathbf{R} = \left[
\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
\end{array}
\right].
\]</div>
</div>
<p>On a side note, such a representation is beneficial when solving,
e.g., a multiclass classification problem by means of <span class="math">\(k\)</span> binary classifiers.</p>
<p>Then, compose another function, but this time setting
<span class="math">\(r_{i,j}=1\)</span> if and only if <span class="math">\(j\ge t_i\)</span>, e.g.:</p>
<div class="math-wrapper docutils container">
<div class="math">
\[
R = \left[
\begin{array}{cccc}
1 & 1 & 1 & 1 \\
0 & 1 & 1 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 \\
\end{array}
\right].
\]</div>
</div>
</div></div><div class="admonition important">
<p class="admonition-title">Important</p>
<p>As usual, try to solve all the exercises without using explicit
<strong class="command">for</strong> and <strong class="command">while</strong> loops (provided that it is possible).</p>
</div>
<div class="proof proof-type-exercise" id="id47">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.32</span>
        
    </div><div class="proof-content">
<p>Given an <span class="math">\(n\times k\)</span> real matrix, apply the softmax
function on each row, i.e., map
<span class="math">\(x_{i,j}\)</span> to <span class="math">\(\frac{\exp(x_{i,j})}{\sum_{l=1}^k \exp(x_{i,l})}\)</span>.
Then, one-hot decode the values in each row, i.e., find the
column number with the greatest value. Return a vector of size <span class="math">\(n\)</span>
with elements in <span class="math">\(\{1,\dots,k\}\)</span>.</p>
</div></div><div class="proof proof-type-exercise" id="id48">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.33</span>
        
    </div><div class="proof-content">
<p>Assume that an <span class="math">\(n\times m\)</span> real matrix <span class="math">\(\mathbf{X}\)</span> represents
<span class="math">\(n\)</span> points in <span class="math">\(\mathbb{R}^m\)</span>. Write a function (but do not refer to
<strong class="command">dist</strong>) that determines the pairwise Euclidean distances between all
the <span class="math">\(n\)</span> points and a given <span class="math">\(\mathbf{y}\in\mathbb{R}^m\)</span>.
Return a vector <span class="math">\(\mathbf{d}\)</span> of length <span class="math">\(n\)</span>
with <span class="math">\(d_{i}=\|\mathbf{x}_{i,\cdot}-\mathbf{y}\|_2\)</span>.</p>
</div></div><div class="proof proof-type-exercise" id="id49">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.34</span>
        
    </div><div class="proof-content">
<p>Let <span class="math">\(\mathbf{X}\)</span> and <span class="math">\(\mathbf{Y}\)</span>
be two real-valued matrices of sizes <span class="math">\(n\times m\)</span> and
<span class="math">\(k\times m\)</span>, respectively, representing two sets of points in <span class="math">\(\mathbb{R}^m\)</span>.
Return an integer vector <span class="math">\(\mathbf{r}\)</span> of length <span class="math">\(k\)</span>
such that <span class="math">\(r_i\)</span> indicates the index of the
point in <span class="math">\(\mathbf{X}\)</span> with the least distance to (the closest to)
the <span class="math">\(i\)</span>-th point in <span class="math">\(\mathbf{Y}\)</span>, i.e.,
<span class="math">\(r_i = \mathrm{arg}\min_j \|\mathbf{x}_{j,\cdot}-\mathbf{y}_{i,\cdot}\|_2\)</span>.</p>
</div></div><div class="proof proof-type-exercise" id="id50">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.35</span>
        
    </div><div class="proof-content">
<p>Write your version of <strong class="program">utils</strong>::<strong class="command">combn</strong>.</p>
</div></div><div class="proof proof-type-exercise" id="id51">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.36</span>
        
    </div><div class="proof-content">
<p>Time series are vectors or matrices of the class <code class="docutils literal notranslate"><span class="pre">ts</span></code>
equipped with the <code class="docutils literal notranslate"><span class="pre">tsp</span></code> attribute, amongst others.
Refer to <strong class="command">help</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;ts&quot;)</span></code> for more information about
how they are represented and what S3 methods have been overloaded for them.</p>
</div></div><div class="proof proof-type-exercise" id="id52">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.37</span>
        
    </div><div class="proof-content">
<p>(*) Numeric matrices can be stored in a CSV file, amongst others.
Usually, we will be loading them via <strong class="command">read.csv</strong>,
which returns a data frame (see <a class="reference internal" href="240-data-frame.html#chap-data-frame"><span class="std std-numref">Chapter 12</span></a>).
For example:</p>
<div class="highlight-r notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.matrix</span><span class="p">(</span><span class="nf">read.csv</span><span class="p">(</span>
<span class="w">    </span><span class="nf">paste0</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;https://github.com/gagolews/teaching-data/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s">&quot;raw/master/marek/eurxxx-20200101-20200630.csv&quot;</span>
<span class="w">    </span><span class="p">),</span>
<span class="w">    </span><span class="n">comment.char</span><span class="o">=</span><span class="s">&quot;#&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="n">sep</span><span class="o">=</span><span class="s">&quot;,&quot;</span>
<span class="p">))</span>
</pre></div>
</div>
<p>Write a function
<strong class="command">read_numeric_matrix</strong><code class="code docutils literal notranslate"><span class="pre">(file_name,</span> <span class="pre">comment,</span> <span class="pre">sep)</span></code>
which is based on a few calls to <strong class="command">scan</strong> instead.
Use <strong class="command">file</strong> to establish a file connection so that you can
ignore the comment lines and fetch the column names
before reading the actual numeric values.</p>
</div></div><div class="proof proof-type-exercise" id="id53">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.38</span>
        
    </div><div class="proof-content">
<p>(*)
Using <strong class="command">readBin</strong>, read the <code class="file docutils literal notranslate"><span class="pre">t10k-images-idx3-ubyte.gz</span></code> from the
<a class="reference external" href="https://web.archive.org/web/20211107114045/http://yann.lecun.com/exdb/mnist">MNIST database homepage</a>.
The output object should be a three-dimensional, <span class="math">\(10000\times 28\times 28\)</span>
array with real elements between 0 and 255. Refer to the <em>File Formats</em>
section therein for more details.</p>
</div></div><div class="proof proof-type-exercise" id="id54">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.39</span>
        
    </div><div class="proof-content">
<p>(**)
Circular convolution of discrete-valued multidimensional signals
can be performed by means of <strong class="command">fft</strong> and matrix multiplication,
whereas affine transformations require only the latter.
Apply various image transformations such as sharpening,
shearing, and rotating on the MNIST digits
and plot the results using the <strong class="command">image</strong> function.</p>
</div></div><div class="proof proof-type-exercise" id="id55">

    <div class="proof-title">
        <span class="proof-type">Exercise 11.40</span>
        
    </div><div class="proof-content">
<p>(*) Using <strong class="command">constrOptim</strong>,
find the minimum of the Constrained Betts Function
<span class="math">\(f(x_1, x_2) = 0.01 x_1^2 + x_2^2 - 100\)</span>
with linear constraints <span class="math">\( 2\le x_1 \le 50\)</span>,
<span class="math">\(-50 \le x_2 \le 50\)</span>, and <span class="math">\(10 x_1 \ge 10 + x_2\)</span>.
(**) Also, use <strong class="command">solve.QP</strong> from the <strong class="command">quadprog</strong>
package to find the minimum.</p>
</div></div><hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footunclass" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>See <a class="reference internal" href="220-s3.html#sec-type-vs-class"><span class="std std-numref">Section 10.1</span></a>. Interestingly,
calling <strong class="command">unclass</strong> on a matrix has no effect.</p>
</aside>
<aside class="footnote brackets" id="footsqover" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Hidden deeply at the C language level; see <strong class="command">help</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;[&quot;)</span></code>.</p>
</aside>
<aside class="footnote brackets" id="footunarymatrix" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>They are simply applied on each
element of the underlying flat vector.
<a class="reference internal" href="150-indexing.html#sec-attrpreserv"><span class="std std-numref">Section 5.5</span></a> mentioned that
unary functions preserve <em>all</em> attributes of their inputs, hence
also <code class="docutils literal notranslate"><span class="pre">dim</span></code> and <code class="docutils literal notranslate"><span class="pre">dimnames</span></code>.</p>
</aside>
<aside class="footnote brackets" id="footblas" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">4</a><span class="fn-bracket">]</span></span>
<p>(*) We can select the underlying implementation
of <code class="docutils literal notranslate"><span class="pre">BLAS</span></code> at R’s compile time; see Section A.3 of
<span id="id12">[<a class="reference internal" href="999-bibliography.html#id12" title="R Development Core Team. (2023).  R Installation and Administration. URL: https://CRAN.R-project.org/doc/manuals/r-release/R-admin.html.">67</a>]</span>. Some of them are faster than others.</p>
</aside>
<aside class="footnote brackets" id="footcopula" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">5</a><span class="fn-bracket">]</span></span>
<p>For drawing random samples from any multivariate distribution,
refer to the theory of copulas, e.g., <span id="id13">[<a class="reference internal" href="999-bibliography.html#id70" title="Nelsen, R.B. (1999).  An Introduction to Copulas. Springer.">49</a>]</span>.
There are a few R packages on CRAN that implement the most popular
models.</p>
</aside>
<aside class="footnote brackets" id="footcomplexqr" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">6</a><span class="fn-bracket">]</span></span>
<p>If <span class="math">\(\mathbf{A}\)</span> is a complex matrix, its QR decomposition
spawns <span class="math">\(\mathbf{Q}\)</span> that is a unitary matrix.</p>
</aside>
<aside class="footnote brackets" id="footregsvd" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">7</a><span class="fn-bracket">]</span></span>
<p>As the pseudoinverse
<span class="math">\(\mathbf{X}^+=\left(\mathbf{X}^T \mathbf{X} \right)^{-1} \mathbf{X}^T
=\mathbf{V} \mathbf{D}^+ \mathbf{U}^T=\mathbf{R}^{-1}\mathbf{Q}^T\)</span>,
with
<span class="math">\(\mathbf{X}^+ \mathbf{X}=\mathbf{I}\)</span>.
Here, <span class="math">\(\mathbf{D}^+\)</span> is a transposed version of <span class="math">\(\mathbf{D}\)</span>
carrying the reciprocals of its non-zero elements.</p>
</aside>
<aside class="footnote brackets" id="footpcasvd" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">8</a><span class="fn-bracket">]</span></span>
<p>See the source code of
<strong class="command">getS3method</strong><code class="code docutils literal notranslate"><span class="pre">(&quot;prcomp&quot;,</span> <span class="pre">&quot;default&quot;)</span></code>.</p>
</aside>
</aside>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="240-data-frame.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title"><span class="section-number">12. </span>Data frames</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="220-s3.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title"><span class="section-number">10. </span>S3 classes</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
              
              
              Copyright &#169; 2022–2024 by <a href="https://www.gagolewski.com/">Marek Gagolewski</a>.
              Some rights reserved. Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/4.0'>CC BY-NC-ND 4.0</a>.
              Built with <a href="https://sphinx-doc.org/">Sphinx</a>
              and a customised <a href="https://github.com/pradyunsg/furo">Furo</a> theme.
              Last updated on 2024-08-26T12:21:30+0200.
              This site will never display any ads: it is a non-profit project.
              It does not collect any data.
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            In this chapter
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">11. Matrices and other arrays</a><ul>
<li><a class="reference internal" href="#creating-arrays">11.1. Creating arrays</a><ul>
<li><a class="reference internal" href="#matrix-and-array">11.1.1. <strong class="command">matrix</strong> and <strong class="command">array</strong></a></li>
<li><a class="reference internal" href="#promoting-and-stacking-vectors">11.1.2. Promoting and stacking vectors</a></li>
<li><a class="reference internal" href="#simplifying-lists">11.1.3. Simplifying lists</a></li>
<li><a class="reference internal" href="#beyond-numeric-arrays">11.1.4. Beyond numeric arrays</a></li>
<li><a class="reference internal" href="#internal-representation">11.1.5. Internal representation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#array-indexing">11.2. Array indexing</a><ul>
<li><a class="reference internal" href="#arrays-are-built-on-basic-vectors">11.2.1. Arrays are built on basic vectors</a></li>
<li><a class="reference internal" href="#selecting-individual-elements">11.2.2. Selecting individual elements</a></li>
<li><a class="reference internal" href="#selecting-rows-and-columns">11.2.3. Selecting rows and columns</a></li>
<li><a class="reference internal" href="#dropping-dimensions">11.2.4. Dropping dimensions</a></li>
<li><a class="reference internal" href="#selecting-submatrices">11.2.5. Selecting submatrices</a></li>
<li><a class="reference internal" href="#selecting-elements-based-on-logical-vectors">11.2.6. Selecting elements based on logical vectors</a></li>
<li><a class="reference internal" href="#selecting-based-on-two-column-numeric-matrices">11.2.7. Selecting based on two-column numeric matrices</a></li>
<li><a class="reference internal" href="#higher-dimensional-arrays">11.2.8. Higher-dimensional arrays</a></li>
<li><a class="reference internal" href="#replacing-elements">11.2.9. Replacing elements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-operations">11.3. Common operations</a><ul>
<li><a class="reference internal" href="#matrix-transpose">11.3.1. Matrix transpose</a></li>
<li><a class="reference internal" href="#vectorised-mathematical-functions">11.3.2. Vectorised mathematical functions</a></li>
<li><a class="reference internal" href="#aggregating-rows-and-columns">11.3.3. Aggregating rows and columns</a></li>
<li><a class="reference internal" href="#binary-operators">11.3.4. Binary operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-matrix-algebra">11.4. Numerical matrix algebra (*)</a><ul>
<li><a class="reference internal" href="#matrix-multiplication">11.4.1. Matrix multiplication</a></li>
<li><a class="reference internal" href="#solving-systems-of-linear-equations">11.4.2. Solving systems of linear equations</a></li>
<li><a class="reference internal" href="#norms-and-metrics">11.4.3. Norms and metrics</a></li>
<li><a class="reference internal" href="#eigenvalues-and-eigenvectors">11.4.4. Eigenvalues and eigenvectors</a></li>
<li><a class="reference internal" href="#qr-decomposition">11.4.5. QR decomposition</a></li>
<li><a class="reference internal" href="#svd-decomposition">11.4.6. SVD decomposition</a></li>
<li><a class="reference internal" href="#a-note-on-the-matrix-package">11.4.7. A note on the <strong class="program">Matrix</strong> package</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises">11.5. Exercises</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=d29a5c0e"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=4e2eecee"></script>
    <script src="../_static/proof.js"></script>
    <script src="../_static/katex.min.js?v=be8ff15f"></script>
    <script src="../_static/auto-render.min.js?v=ad136472"></script>
    <script src="../_static/katex_autorenderer.js?v=bebc588a"></script>
    </body>
</html>